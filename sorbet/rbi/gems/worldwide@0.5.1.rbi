# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `worldwide` gem.
# Please instead update this file by running `bin/tapioca gem worldwide`.

# source://worldwide//lib/worldwide/config.rb#3
module Worldwide
  class << self
    # source://worldwide//lib/worldwide.rb#46
    def address(**kwargs); end

    # source://worldwide//lib/worldwide.rb#50
    def currency(code:); end

    # source://worldwide//lib/worldwide.rb#55
    def discounts; end

    # source://worldwide//lib/worldwide.rb#67
    def lists; end

    # source://worldwide//lib/worldwide.rb#59
    def locale(code:); end

    # source://worldwide//lib/worldwide.rb#63
    def locales; end

    # source://worldwide//lib/worldwide.rb#71
    def names; end

    # source://worldwide//lib/worldwide.rb#75
    def numbers; end

    # source://worldwide//lib/worldwide.rb#79
    def plurals; end

    # source://worldwide//lib/worldwide.rb#83
    def punctuation; end

    # source://worldwide//lib/worldwide.rb#91
    def region(**kwargs); end

    # source://worldwide//lib/worldwide.rb#87
    def region_by_cldr_code(**kwargs); end

    # source://worldwide//lib/worldwide.rb#95
    def scripts; end

    # source://worldwide//lib/worldwide.rb#99
    def time_zone; end

    # source://worldwide//lib/worldwide.rb#107
    def units; end

    # source://worldwide//lib/worldwide.rb#103
    def unknown_region; end
  end
end

# source://worldwide//lib/worldwide/address.rb#4
class Worldwide::Address
  # @return [Address] a new instance of Address
  #
  # source://worldwide//lib/worldwide/address.rb#16
  def initialize(first_name: T.unsafe(nil), last_name: T.unsafe(nil), company: T.unsafe(nil), address1: T.unsafe(nil), address2: T.unsafe(nil), zip: T.unsafe(nil), city: T.unsafe(nil), province_code: T.unsafe(nil), country_code: T.unsafe(nil), phone: T.unsafe(nil)); end

  # Returns the value of attribute address1.
  #
  # source://worldwide//lib/worldwide/address.rb#5
  def address1; end

  # Returns the value of attribute address2.
  #
  # source://worldwide//lib/worldwide/address.rb#5
  def address2; end

  # Returns the value of attribute city.
  #
  # source://worldwide//lib/worldwide/address.rb#5
  def city; end

  # Returns the value of attribute company.
  #
  # source://worldwide//lib/worldwide/address.rb#5
  def company; end

  # Returns the value of attribute country_code.
  #
  # source://worldwide//lib/worldwide/address.rb#5
  def country_code; end

  # source://worldwide//lib/worldwide/address.rb#40
  def errors; end

  # Returns the value of attribute first_name.
  #
  # source://worldwide//lib/worldwide/address.rb#5
  def first_name; end

  # source://worldwide//lib/worldwide/address.rb#44
  def format(additional_lines: T.unsafe(nil), excluded_fields: T.unsafe(nil)); end

  # Returns the value of attribute last_name.
  #
  # source://worldwide//lib/worldwide/address.rb#5
  def last_name; end

  # source://worldwide//lib/worldwide/address.rb#57
  def normalize(autocorrect_level: T.unsafe(nil)); end

  # source://worldwide//lib/worldwide/address.rb#61
  def normalize!(autocorrect_level: T.unsafe(nil)); end

  # Returns the value of attribute phone.
  #
  # source://worldwide//lib/worldwide/address.rb#5
  def phone; end

  # Returns the value of attribute province_code.
  #
  # source://worldwide//lib/worldwide/address.rb#5
  def province_code; end

  # source://worldwide//lib/worldwide/address.rb#72
  def single_line(additional_lines: T.unsafe(nil), excluded_fields: T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://worldwide//lib/worldwide/address.rb#132
  def valid?; end

  # Returns the value of attribute zip.
  #
  # source://worldwide//lib/worldwide/address.rb#5
  def zip; end

  private

  # source://worldwide//lib/worldwide/address.rb#142
  def address_format_array; end

  # source://worldwide//lib/worldwide/address.rb#146
  def address_format_string; end

  # For Brazil, there's a convention that, when printing on a single line, there should be
  # commas between the fields except:
  #  - between address1 and address2, and between city and province, there should be a hyphen-minus
  #  - between zip and city, there should be a space with no comma
  #
  # source://worldwide//lib/worldwide/address.rb#168
  def adjust_single_line_format_for_brazil(lines:, excluded_fields:); end

  # @return [Boolean]
  #
  # source://worldwide//lib/worldwide/address.rb#221
  def blank?(text); end

  # Returns an array of lines containing the positions into which each field should be substituted,
  # e.g. ["{firstName} {lastName}", "{address1}", "{address2}", "{city} {province} {zip}", "{country}"]
  #
  # source://worldwide//lib/worldwide/address.rb#227
  def build_address_format_array(additional_lines:, excluded_fields:); end

  # Post-processes the output of build_address_format_array(), adding a LTR mark for the {phone} field
  # and enforcing snake_case for field names.
  # Fill in fields (e.g. "{city}") with their values (e.g. "London")
  #
  # source://worldwide//lib/worldwide/address.rb#263
  def build_filled_address_data(additional_lines:, excluded_fields:); end

  # Returns a hash containing the values for each address field
  #
  # source://worldwide//lib/worldwide/address.rb#245
  def build_formatted_address_data; end

  # source://worldwide//lib/worldwide/address.rb#279
  def fill_in_fields(fields:, address_data:); end

  # source://worldwide//lib/worldwide/address.rb#273
  def fill_in_lines(lines:, address_data:); end

  # @return [Boolean]
  #
  # source://worldwide//lib/worldwide/address.rb#296
  def japan_with_non_japanese_script?; end

  # source://worldwide//lib/worldwide/address.rb#302
  def normalize_city; end

  # source://worldwide//lib/worldwide/address.rb#306
  def normalize_country_code(autocorrect_level:); end

  # source://worldwide//lib/worldwide/address.rb#320
  def normalize_field_names(fields); end

  # source://worldwide//lib/worldwide/address.rb#333
  def normalize_phone; end

  # source://worldwide//lib/worldwide/address.rb#345
  def normalize_province_code; end

  # source://worldwide//lib/worldwide/address.rb#362
  def normalize_zip; end

  # source://worldwide//lib/worldwide/address.rb#366
  def province_name; end

  # source://worldwide//lib/worldwide/address.rb#379
  def snake_to_camel_case(value); end

  # Post-process to strip extraneous characters and whitespace
  #
  # source://worldwide//lib/worldwide/address.rb#388
  def strip_extra_chars(lines:, excluded_fields:); end

  # For Japan (and, so far, only for Japan) we have a couple of special characters as part of the
  # address format string:
  #   - `様` ("-sama") is a gender-neutral, polite-form suffix that's appended to a name
  #   - `〒` ("yuubin" mark) is a prefix that's prepended to the postal code (zip)
  # If the associated field is excluded/empty, we need to suppress the associated special character.
  #
  # source://worldwide//lib/worldwide/address.rb#407
  def strip_extra_japanese_chars(line:, excluded_fields:); end
end

# source://worldwide//lib/worldwide/address.rb#71
Worldwide::Address::COUNTRIES_USING_REVERSE_ADDRESS_ORDER = T.let(T.unsafe(nil), Array)

# source://worldwide//lib/worldwide/address.rb#294
Worldwide::Address::JAPANESE_SCRIPTS = T.let(T.unsafe(nil), Array)

# source://worldwide//lib/worldwide/address.rb#138
Worldwide::Address::LINE_SEP = T.let(T.unsafe(nil), String)

# source://worldwide//lib/worldwide/address.rb#140
Worldwide::Address::WORD_SEP = T.let(T.unsafe(nil), String)

# source://worldwide//lib/worldwide/address_validator.rb#7
class Worldwide::AddressValidator
  include ::Singleton
  extend ::Singleton::SingletonClassMethods

  # Return an array of diagnostics about the validity of this address.
  # If no problems are found, then the result will be an empty array.
  #
  # source://worldwide//lib/worldwide/address_validator.rb#17
  def errors(address); end

  # Return true if (as far as we know) the address is valid.
  # Return false if we know of at least one error with the address.
  #
  # @return [Boolean]
  #
  # source://worldwide//lib/worldwide/address_validator.rb#34
  def valid?(address); end

  private

  # source://worldwide//lib/worldwide/address_validator.rb#42
  def city_errors(address); end

  # source://worldwide//lib/worldwide/address_validator.rb#50
  def country_errors(address); end

  # source://worldwide//lib/worldwide/address_validator.rb#63
  def phone_errors(address); end

  # source://worldwide//lib/worldwide/address_validator.rb#71
  def province_errors(address); end

  # source://worldwide//lib/worldwide/address_validator.rb#91
  def zip_errors(address); end

  class << self
    # source://forwardable/1.3.3/forwardable.rb#231
    def errors(*args, **_arg1, &block); end

    # source://forwardable/1.3.3/forwardable.rb#231
    def valid?(*args, **_arg1, &block); end

    private

    def allocate; end
    def new(*_arg0); end
  end
end

# source://worldwide//lib/worldwide/calendar/gregorian.rb#4
module Worldwide::Calendar
  class << self
    # source://worldwide//lib/worldwide/calendar.rb#8
    def first_week_day(territory_code); end

    private

    # source://worldwide//lib/worldwide/calendar.rb#14
    def first_day_data; end
  end
end

# source://worldwide//lib/worldwide/calendar/gregorian.rb#5
class Worldwide::Calendar::Gregorian
  class << self
    # @raise [ArgumentError]
    #
    # source://worldwide//lib/worldwide/calendar/gregorian.rb#17
    def month_names(width: T.unsafe(nil), locale: T.unsafe(nil)); end

    # source://worldwide//lib/worldwide/calendar/gregorian.rb#23
    def quarter(date, locale: T.unsafe(nil)); end

    # @raise [ArgumentError]
    #
    # source://worldwide//lib/worldwide/calendar/gregorian.rb#10
    def weekday_names(width: T.unsafe(nil), locale: T.unsafe(nil)); end
  end
end

# source://worldwide//lib/worldwide/cldr/date_format_pattern.rb#6
module Worldwide::Cldr
  class << self
    # source://worldwide//lib/worldwide/cldr.rb#19
    def config; end

    # source://worldwide//lib/worldwide/cldr.rb#15
    def fallbacks; end

    private

    # source://worldwide//lib/worldwide/cldr.rb#29
    def method_missing(method_name, *args, **kwargs, &block); end

    # @return [Boolean]
    #
    # source://worldwide//lib/worldwide/cldr.rb#25
    def respond_to_missing?(method_name, include_private = T.unsafe(nil)); end

    # source://worldwide//lib/worldwide/cldr.rb#35
    def with_cldr(&block); end
  end
end

# source://worldwide//lib/worldwide/cldr.rb#10
Worldwide::Cldr::CONFIG = T.let(T.unsafe(nil), Worldwide::RubyI18nConfig)

# source://worldwide//lib/worldwide/cldr/context_transforms.rb#5
class Worldwide::Cldr::ContextTransforms
  class << self
    # source://worldwide//lib/worldwide/cldr/context_transforms.rb#21
    def for(usage, context, locale: T.unsafe(nil)); end

    # source://worldwide//lib/worldwide/cldr/context_transforms.rb#17
    def transform(string, usage, context, locale: T.unsafe(nil)); end
  end
end

# source://worldwide//lib/worldwide/cldr/context_transforms.rb#6
Worldwide::Cldr::ContextTransforms::TRANSFORMS = T.let(T.unsafe(nil), Hash)

# source://worldwide//lib/worldwide/cldr/date_format_pattern.rb#7
class Worldwide::Cldr::DateFormatPattern
  class << self
    # Populate a CLDR format string using a Date
    # TODO: Implement all the date fields
    #
    # source://worldwide//lib/worldwide/cldr/date_format_pattern.rb#13
    def format(date, format, locale: T.unsafe(nil)); end

    # source://worldwide//lib/worldwide/cldr/date_format_pattern.rb#27
    def tokenize(format); end

    private

    # source://worldwide//lib/worldwide/cldr/date_format_pattern.rb#52
    def parse_field(format); end

    # source://worldwide//lib/worldwide/cldr/date_format_pattern.rb#66
    def parse_quoted_literal(format); end

    # source://worldwide//lib/worldwide/cldr/date_format_pattern.rb#59
    def parse_single_quote(format); end

    # source://worldwide//lib/worldwide/cldr/date_format_pattern.rb#73
    def parse_unquoted_literal(format); end
  end
end

# source://worldwide//lib/worldwide/cldr/date_format_pattern.rb#101
class Worldwide::Cldr::DateFormatPattern::EraField < ::Worldwide::Cldr::DateFormatPattern::Field
  # source://worldwide//lib/worldwide/cldr/date_format_pattern.rb#104
  def format(date, locale: T.unsafe(nil)); end
end

# source://worldwide//lib/worldwide/cldr/date_format_pattern.rb#102
Worldwide::Cldr::DateFormatPattern::EraField::GREGORIAN_COMMON_ERA_BOUNDARY = T.let(T.unsafe(nil), Date)

# source://worldwide//lib/worldwide/cldr/date_format_pattern.rb#160
Worldwide::Cldr::DateFormatPattern::FIELD_CLASSES = T.let(T.unsafe(nil), Hash)

# source://worldwide//lib/worldwide/cldr/date_format_pattern.rb#81
class Worldwide::Cldr::DateFormatPattern::Field
  # @return [Field] a new instance of Field
  #
  # source://worldwide//lib/worldwide/cldr/date_format_pattern.rb#91
  def initialize(pattern); end

  # @raise [NotImplementedError]
  #
  # source://worldwide//lib/worldwide/cldr/date_format_pattern.rb#95
  def format(date, locale: T.unsafe(nil)); end

  # Returns the value of attribute pattern.
  #
  # source://worldwide//lib/worldwide/cldr/date_format_pattern.rb#89
  def pattern; end

  class << self
    # source://worldwide//lib/worldwide/cldr/date_format_pattern.rb#83
    def from(pattern); end
  end
end

# source://worldwide//lib/worldwide/cldr/date_format_pattern.rb#8
class Worldwide::Cldr::DateFormatPattern::InvalidPattern < ::StandardError; end

# source://worldwide//lib/worldwide/cldr/date_format_pattern.rb#99
class Worldwide::Cldr::DateFormatPattern::Literal < ::Struct
  # Returns the value of attribute value
  #
  # @return [Object] the current value of value
  def value; end

  # Sets the attribute value
  #
  # @param value [Object] the value to set the attribute value to.
  # @return [Object] the newly set value
  def value=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

# source://worldwide//lib/worldwide/cldr/date_format_pattern.rb#119
class Worldwide::Cldr::DateFormatPattern::QuarterField < ::Worldwide::Cldr::DateFormatPattern::Field
  # @return [QuarterField] a new instance of QuarterField
  #
  # source://worldwide//lib/worldwide/cldr/date_format_pattern.rb#120
  def initialize(pattern); end

  # source://worldwide//lib/worldwide/cldr/date_format_pattern.rb#125
  def format(date, locale: T.unsafe(nil)); end

  private

  # Returns the value of attribute format_type.
  #
  # source://worldwide//lib/worldwide/cldr/date_format_pattern.rb#146
  def format_type; end
end

# source://worldwide//lib/worldwide/cldr/date_format_pattern.rb#149
class Worldwide::Cldr::DateFormatPattern::YearField < ::Worldwide::Cldr::DateFormatPattern::Field
  # source://worldwide//lib/worldwide/cldr/date_format_pattern.rb#150
  def format(date, locale: T.unsafe(nil)); end
end

# source://worldwide//lib/worldwide/cldr.rb#9
Worldwide::Cldr::FALLBACKS = T.let(T.unsafe(nil), Worldwide::Cldr::Fallbacks)

# source://worldwide//lib/worldwide/cldr/fallbacks.rb#5
class Worldwide::Cldr::Fallbacks < ::Hash
  # @return [Fallbacks] a new instance of Fallbacks
  #
  # source://worldwide//lib/worldwide/cldr/fallbacks.rb#6
  def initialize; end

  # source://worldwide//lib/worldwide/cldr/fallbacks.rb#12
  def [](locale); end

  # source://worldwide//lib/worldwide/cldr/fallbacks.rb#22
  def defined_parent_locales; end

  # source://worldwide//lib/worldwide/cldr/fallbacks.rb#17
  def descendants(locale); end

  private

  # source://worldwide//lib/worldwide/cldr/fallbacks.rb#32
  def ancestry(locale); end

  # source://worldwide//lib/worldwide/cldr/fallbacks.rb#28
  def cldr_defined_parents; end

  # Walk through all known locales, calculating their ancestry, and caching the results
  #
  # source://worldwide//lib/worldwide/cldr/fallbacks.rb#48
  def compute_all_ancestors; end
end

# source://worldwide//lib/worldwide/config.rb#4
module Worldwide::Config
  class << self
    # source://worldwide//lib/worldwide/config.rb#22
    def configure_i18n(i18n_config: T.unsafe(nil), additional_components: T.unsafe(nil)); end

    # source://worldwide//lib/worldwide/config.rb#51
    def exception_handler; end

    private

    # source://worldwide//lib/worldwide/config.rb#98
    def add_cldr_data(i18n_config, additional_components:); end

    # source://worldwide//lib/worldwide/config.rb#105
    def add_other_data(i18n_config); end

    # source://worldwide//lib/worldwide/config.rb#82
    def expanded_locales_from_configuration(i18n_config); end

    # @return [Boolean]
    #
    # source://worldwide//lib/worldwide/config.rb#57
    def i18n_defined?(i18n_config, key); end

    # source://worldwide//lib/worldwide/config.rb#75
    def set_unless_explicitly_set(i18n_config, key, value); end
  end
end

# The list of CLDR data components needed by this gem
# Users can add more data components to this list if they want to use them
#
# source://worldwide//lib/worldwide/config.rb#7
Worldwide::Config::REQUIRED_CLDR_DATA = T.let(T.unsafe(nil), Array)

# source://worldwide//lib/worldwide/currencies.rb#4
module Worldwide::Currencies
  include ::Enumerable
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
  extend ::Enumerable
  extend ::Worldwide::Currencies

  # source://worldwide//lib/worldwide/currencies.rb#14
  def all; end

  # Convert ISO-4217 numeric-three code to ISO-4217 alpha-three code
  # Returns nil if there is no such numeric code.
  #
  # source://worldwide//lib/worldwide/currencies.rb#20
  def alpha_code_for(numeric_code); end

  # source://worldwide//lib/worldwide/currencies.rb#10
  def each(&block); end

  # Convert ISO-4217 alpha-three code to ISO-4217 numeric-three code
  # Note that we support some currencies (e.g. JEP) that are not recognized by ISO,
  # and there is no numeric-three code for these currencies, so nil will be returned.
  #
  # source://worldwide//lib/worldwide/currencies.rb#32
  def numeric_code_for(alpha_code); end

  private

  # source://worldwide//lib/worldwide/currencies.rb#38
  def all_currencies; end

  # source://worldwide//lib/worldwide/currencies.rb#47
  def currency_codes; end

  # source://worldwide//lib/worldwide/currencies.rb#51
  def map_alpha_three_to_numeric_three; end

  # source://worldwide//lib/worldwide/currencies.rb#55
  def numeric_three_to_alpha_three_db; end
end

# source://worldwide//lib/worldwide/currencies.rb#7
Worldwide::Currencies::CURRENCIES_FILE_PATH = T.let(T.unsafe(nil), String)

# source://worldwide//lib/worldwide/currencies.rb#8
Worldwide::Currencies::CURRENCY_CODES_FILE_PATH = T.let(T.unsafe(nil), String)

# source://worldwide//lib/worldwide/currency.rb#5
class Worldwide::Currency
  include ::Worldwide::PluralizationHelper

  # @return [Currency] a new instance of Currency
  #
  # source://worldwide//lib/worldwide/currency.rb#29
  def initialize(code:); end

  # Returns the value of attribute currency_code.
  #
  # source://worldwide//lib/worldwide/currency.rb#27
  def currency_code; end

  # Returns the number of decimal places needed to represent the currency's minor unit
  #
  # source://worldwide//lib/worldwide/currency.rb#43
  def decimals; end

  # returns the amount formatted using the explicit currency code in the given locale
  #
  # source://worldwide//lib/worldwide/currency.rb#93
  def format_explicit(amount, as_minor_units: T.unsafe(nil), decimal_places: T.unsafe(nil), humanize: T.unsafe(nil), locale: T.unsafe(nil), use_symbol: T.unsafe(nil)); end

  # returns the amount formatted using the short-form symbol in the given locale
  #
  # source://worldwide//lib/worldwide/currency.rb#48
  def format_short(amount, as_minor_units: T.unsafe(nil), decimal_places: T.unsafe(nil), humanize: T.unsafe(nil), locale: T.unsafe(nil), use_symbol: T.unsafe(nil)); end

  # source://worldwide//lib/worldwide/currency.rb#144
  def label(count: T.unsafe(nil)); end

  # source://worldwide//lib/worldwide/currency.rb#150
  def name; end

  # Returns the value of attribute numeric_code.
  #
  # source://worldwide//lib/worldwide/currency.rb#27
  def numeric_code; end

  # source://worldwide//lib/worldwide/currency.rb#116
  def symbol(locale: T.unsafe(nil)); end

  private

  # source://worldwide//lib/worldwide/currency.rb#156
  def combine(amount:, decimal_places:, humanize:, locale:, symbol:); end

  # Supports alternative formatting, specified in the humanize: keyword argument.
  # Currently, only :japan is available, which will use the 円 style for JPY.
  #
  # source://worldwide//lib/worldwide/currency.rb#184
  def format_alternate(amount, decimal_places:, humanize:, locale:, use_symbol:); end

  # source://worldwide//lib/worldwide/currency.rb#210
  def format_currency_text(label); end

  # source://worldwide//lib/worldwide/currency.rb#214
  def format_minor_units(amount, decimal_places:, humanize:, locale:); end

  # source://worldwide//lib/worldwide/currency.rb#227
  def formatted_amount(amount, decimal_places:, humanize:, locale:); end

  # @return [Boolean]
  #
  # source://worldwide//lib/worldwide/currency.rb#235
  def has_minor_symbol?; end

  # Returns true if there should be a space between the amount and the currency symbol
  #
  # source://worldwide//lib/worldwide/currency.rb#240
  def has_space(locale); end

  # source://worldwide//lib/worldwide/currency.rb#250
  def minor_symbol; end

  # Returns true if the currency symbol is a prefix, e.g. "$ 12.00".
  # Returns false if the currency symbol is a suffix. e.g. "12.00 $".
  #
  # @return [Boolean]
  #
  # source://worldwide//lib/worldwide/currency.rb#260
  def prefix?(locale); end

  class << self
    # source://worldwide//lib/worldwide/currency.rb#14
    def digits_and_rounding; end

    # source://worldwide//lib/worldwide/currency.rb#20
    def minor_symbols; end
  end
end

# source://worldwide//lib/worldwide/currency.rb#8
Worldwide::Currency::EXCEPTIONS = T.let(T.unsafe(nil), Hash)

# source://worldwide//lib/worldwide/currency.rb#9
Worldwide::Currency::SUPPORTED_ALTERNATE_FORMATS = T.let(T.unsafe(nil), Array)

# source://worldwide//lib/worldwide/currency.rb#10
Worldwide::Currency::TEXT_ENCLOSED_BY_PARENTHESES = T.let(T.unsafe(nil), Regexp)

# source://worldwide//lib/worldwide/deprecated_time_zone_mapper.rb#4
class Worldwide::DeprecatedTimeZoneMapper
  class << self
    # If the zone name is deprecated, return the supported zone name that corresponds to it.
    # If the zone name is supported, return it unchanged.
    #
    # source://worldwide//lib/worldwide/deprecated_time_zone_mapper.rb#8
    def to_supported(zone); end
  end
end

# source://worldwide//lib/worldwide/deprecated_time_zone_mapper.rb#13
Worldwide::DeprecatedTimeZoneMapper::DEPRECATED_ZONES_MAP = T.let(T.unsafe(nil), Hash)

# source://worldwide//lib/worldwide/discounts.rb#4
class Worldwide::Discounts
  class << self
    # source://worldwide//lib/worldwide/discounts.rb#9
    def format(discount_percent, locale: T.unsafe(nil)); end

    private

    # source://worldwide//lib/worldwide/discounts.rb#24
    def format_default(discount_percent, locale:); end

    # Discounts in Japanese are formatted in tenths if applicable (20% Off => 2割引, 25% Off => 25%割引)
    #
    # source://worldwide//lib/worldwide/discounts.rb#41
    def format_ja(discount_percent, locale:); end

    # Discounts in Kurdish are formatted using English percentage conventions in a Latin script context
    #
    # source://worldwide//lib/worldwide/discounts.rb#29
    def format_ku(discount_percent, locale:); end

    # Discounts in Chinese are formatted as a fraction of the original price (20% Off => 8折, 25% Off => 7.5折)
    #
    # source://worldwide//lib/worldwide/discounts.rb#34
    def format_zh_hans(discount_percent, locale:); end

    # @return [Boolean]
    #
    # source://worldwide//lib/worldwide/discounts.rb#52
    def integer?(num); end
  end
end

# source://worldwide//lib/worldwide/discounts.rb#6
Worldwide::Discounts::KU_GROUP = T.let(T.unsafe(nil), Array)

# source://worldwide//lib/worldwide/discounts.rb#5
Worldwide::Discounts::ZH_HANS_GROUP = T.let(T.unsafe(nil), Array)

# source://worldwide//lib/worldwide/field.rb#8
class Worldwide::Field
  # @return [Field] a new instance of Field
  #
  # source://worldwide//lib/worldwide/field.rb#22
  def initialize(country_code:, field_key:); end

  # source://worldwide//lib/worldwide/field.rb#27
  def autofill(locale: T.unsafe(nil)); end

  # source://worldwide//lib/worldwide/field.rb#39
  def error(code:, locale: T.unsafe(nil), options: T.unsafe(nil)); end

  # source://worldwide//lib/worldwide/field.rb#31
  def label(locale: T.unsafe(nil)); end

  # source://worldwide//lib/worldwide/field.rb#35
  def label_marked_optional(locale: T.unsafe(nil)); end

  private

  # source://worldwide//lib/worldwide/field.rb#45
  def base_key(country_key); end

  # source://worldwide//lib/worldwide/field.rb#49
  def default_lookup(key_suffix, options: T.unsafe(nil)); end

  # source://worldwide//lib/worldwide/field.rb#55
  def lookup(key_suffix, locale:, options: T.unsafe(nil)); end
end

# source://worldwide//lib/worldwide/field.rb#9
Worldwide::Field::VALID_KEYS = T.let(T.unsafe(nil), Array)

# source://worldwide//lib/worldwide/fields.rb#10
class Worldwide::Fields
  include ::Singleton
  extend ::Singleton::SingletonClassMethods

  # @return [Fields] a new instance of Fields
  #
  # source://worldwide//lib/worldwide/fields.rb#18
  def initialize; end

  # Return a Worldwide::Field for the specified country_code and field_key
  #
  # source://worldwide//lib/worldwide/fields.rb#23
  def field(country_code:, field_key:); end

  class << self
    # source://forwardable/1.3.3/forwardable.rb#231
    def field(*args, **_arg1, &block); end

    private

    def allocate; end
    def new(*_arg0); end
  end
end

# source://worldwide//lib/worldwide/i18n_exception_handler.rb#4
class Worldwide::I18nExceptionHandler < ::I18n::ExceptionHandler
  # I18n.exception_handler is needed in cases where the lookup has
  # gone through the fallback chain. In that case, we want to do the
  # lookup in the default locale.
  #
  # It's a common misconception that we should add the default locale
  # to the fallbacks chain. Instead, you catch the exception and do
  # the lookup in the source locale.
  #
  # source://worldwide//lib/worldwide/i18n_exception_handler.rb#12
  def call(exception, locale, key, options, context = T.unsafe(nil)); end

  private

  # Rails i18n view logic uses `titleize`.
  # In order to avoid a dependency over Rails, implementing a minimal version.
  #
  # source://worldwide//lib/worldwide/i18n_exception_handler.rb#51
  def degraded_translation(key, options); end

  # source://worldwide//lib/worldwide/i18n_exception_handler.rb#43
  def handle_default_locale_fallback(exception, _locale, key, options, context); end

  # source://worldwide//lib/worldwide/i18n_exception_handler.rb#28
  def handle_missing_translation(exception, _locale, key, options); end

  # source://worldwide//lib/worldwide/i18n_exception_handler.rb#59
  def log_missing(exception); end

  # source://worldwide//lib/worldwide/i18n_exception_handler.rb#63
  def report_error(exception); end
end

# source://worldwide//lib/worldwide/lists.rb#4
module Worldwide::Lists
  extend ::Worldwide::Lists

  # We assume that the data is expected to returned in the same
  # order as it is received. We are aware of one counter example,
  # Urdu, that we do not support.
  #
  # source://worldwide//lib/worldwide/lists.rb#10
  def format(data, join: T.unsafe(nil), locale: T.unsafe(nil)); end

  private

  # source://worldwide//lib/worldwide/lists.rb#41
  def get_connector(cldr_connector, position:, locale:); end
end

# source://worldwide//lib/worldwide/locale.rb#4
class Worldwide::Locale
  # @return [Locale] a new instance of Locale
  #
  # source://worldwide//lib/worldwide/locale.rb#14
  def initialize(code); end

  # Returns the value of attribute code.
  #
  # source://worldwide//lib/worldwide/locale.rb#12
  def code; end

  # The language's name in that language ("endonym").
  #
  # source://worldwide//lib/worldwide/locale.rb#84
  def endonym(context: T.unsafe(nil), throw: T.unsafe(nil)); end

  # source://worldwide//lib/worldwide/locale.rb#23
  def language_subtag; end

  # source://worldwide//lib/worldwide/locale.rb#52
  def name(locale: T.unsafe(nil), context: T.unsafe(nil), throw: T.unsafe(nil)); end

  # source://worldwide//lib/worldwide/locale.rb#27
  def script; end

  # source://worldwide//lib/worldwide/locale.rb#48
  def sub_locales; end

  private

  # source://worldwide//lib/worldwide/locale.rb#140
  def chop(string, separator); end

  # source://worldwide//lib/worldwide/locale.rb#107
  def exonym(target_locale:, context:); end

  # source://worldwide//lib/worldwide/locale.rb#132
  def lookup(key, locale:); end

  # source://worldwide//lib/worldwide/locale.rb#124
  def name_in_default_locale(context:); end

  # source://worldwide//lib/worldwide/locale.rb#153
  def territories_suffix(target_code); end

  class << self
    # source://worldwide//lib/worldwide/locale.rb#6
    def unknown; end
  end
end

# source://worldwide//lib/worldwide/locales.rb#6
module Worldwide::Locales
  extend ::Enumerable

  class << self
    # source://worldwide//lib/worldwide/locales.rb#12
    def each(&block); end

    def known(*_arg0); end

    # source://worldwide//lib/worldwide/locales.rb#16
    def likely_subtags; end

    # source://worldwide//lib/worldwide/locales.rb#28
    def sub_locales; end

    # source://worldwide//lib/worldwide/locales.rb#22
    def top_25; end

    private

    # source://worldwide//lib/worldwide/locales.rb#43
    def cldr_locales; end
  end
end

# source://worldwide//lib/worldwide/units.rb#9
Worldwide::MEASUREMENT_KEYS = T.let(T.unsafe(nil), Hash)

# source://worldwide//lib/worldwide/names.rb#4
class Worldwide::Names
  class << self
    # source://worldwide//lib/worldwide/names.rb#15
    def full(given:, surname:); end

    # source://worldwide//lib/worldwide/names.rb#19
    def greeting(given:, surname:); end

    # source://worldwide//lib/worldwide/names.rb#23
    def initials(given:, surname:); end

    # @return [Boolean]
    #
    # source://worldwide//lib/worldwide/names.rb#9
    def surname_first?(locale); end

    private

    # source://worldwide//lib/worldwide/names.rb#35
    def format_name(format, given, surname); end

    # source://worldwide//lib/worldwide/names.rb#48
    def language_subtag(locale); end
  end
end

# source://worldwide//lib/worldwide/numbers.rb#4
class Worldwide::Numbers
  # @return [Numbers] a new instance of Numbers
  #
  # source://worldwide//lib/worldwide/numbers.rb#11
  def initialize(locale: T.unsafe(nil)); end

  # source://worldwide//lib/worldwide/numbers.rb#15
  def format(amount, decimal_places: T.unsafe(nil), humanize: T.unsafe(nil), percent: T.unsafe(nil), relative: T.unsafe(nil)); end

  private

  # source://worldwide//lib/worldwide/numbers.rb#56
  def add_group_markers(value); end

  # source://worldwide//lib/worldwide/numbers.rb#90
  def add_japan_group_markers(value); end

  # source://worldwide//lib/worldwide/numbers.rb#104
  def add_percent_sign(value); end

  # source://worldwide//lib/worldwide/numbers.rb#115
  def add_relative_marker(amount, representation); end

  # https://www.unicode.org/reports/tr35/tr35-numbers.html#Compact_Number_Formats
  # > N is divided by the type, after removing the number of zeros in the pattern, less 1.
  #
  # source://worldwide//lib/worldwide/numbers.rb#244
  def compact_format_scale_factor(matched_type, style:); end

  # Scan the list of number formats given in CLDR, and find the closest match
  # https://www.unicode.org/reports/tr35/tr35-numbers.html#Compact_Number_Formats
  # > To format a number N, the greatest type less than or equal to N is used,
  # > with the appropriate plural category.
  #
  # source://worldwide//lib/worldwide/numbers.rb#226
  def compact_format_type(number, style:); end

  # source://worldwide//lib/worldwide/numbers.rb#123
  def decimal_marker; end

  # This approximately implements compact number formatting as described in CLDR
  # https://unicode.org/reports/tr35/tr35-numbers.html#Compact_Number_Formats
  # It's not quite right, since it relies on format_default, which doesn't quite follow CLDR's spec.
  #
  # source://worldwide//lib/worldwide/numbers.rb#174
  def format_compact(number, style:, decimal_places: T.unsafe(nil)); end

  # source://worldwide//lib/worldwide/numbers.rb#37
  def format_default(number, decimal_places:, humanize:); end

  # source://worldwide//lib/worldwide/numbers.rb#127
  def group_marker; end

  # Returns an array of digit grouping sizes (for splitting large numbers, e.g., into thousands)
  # Either [primary_group_size, secondary_group_size], or [primary_group_size], depending on locale.
  #
  # Examples:
  #
  # Many locales group by thousands (sets of 3 digits).  Thus, one million is written 1,000,000.
  # The returned value will be [3] for those locales.
  #
  # The Indian subcontinent and Burma group the initial 3 digits together, but subsequently group by
  # sets of 2 digits.  Thus, one million is written as 10,00,000 (and spoken as "ten lakh").
  # The returned value will be [3, 2] for those locales.
  #
  # source://worldwide//lib/worldwide/numbers.rb#143
  def group_positions; end

  # Returns the value of attribute locale.
  #
  # source://worldwide//lib/worldwide/numbers.rb#35
  def locale; end

  # Figure out how many decimal places would naturally be required to display the given number.
  #
  # source://worldwide//lib/worldwide/numbers.rb#258
  def natural_decimal_places(number); end

  # @return [Boolean]
  #
  # source://worldwide//lib/worldwide/numbers.rb#238
  def numeric?(character); end

  # source://worldwide//lib/worldwide/numbers.rb#268
  def percent_sign; end

  # Returns true if the current locale uses a trailing percent sign (e.g., "50%") in
  # numeric layout order (which is always left-to-right, regardless of locale).
  # Otherwise (if the locale uses a leading percent sign, e.g., "%50") returns false.
  #
  # source://worldwide//lib/worldwide/numbers.rb#276
  def percentage_specification; end
end

# source://worldwide//lib/worldwide/numbers.rb#7
Worldwide::Numbers::CLDR_COMPACT_STYLE = T.let(T.unsafe(nil), Array)

# source://worldwide//lib/worldwide/numbers.rb#8
Worldwide::Numbers::COMPACT_DECIMAL_BASE_KEY = T.let(T.unsafe(nil), String)

# source://worldwide//lib/worldwide/numbers.rb#9
Worldwide::Numbers::DEFAULT_COMPACT_PATTERN = T.let(T.unsafe(nil), String)

# source://worldwide//lib/worldwide/numbers.rb#5
Worldwide::Numbers::JAPAN_MYRIAD_UNITS = T.let(T.unsafe(nil), Array)

# source://worldwide//lib/worldwide/paths.rb#4
module Worldwide::Paths; end

# source://worldwide//lib/worldwide/paths.rb#7
Worldwide::Paths::CLDR_ROOT = T.let(T.unsafe(nil), String)

# source://worldwide//lib/worldwide/paths.rb#6
Worldwide::Paths::DATA_ROOT = T.let(T.unsafe(nil), String)

# source://worldwide//lib/worldwide/paths.rb#10
Worldwide::Paths::DB_DATA_ROOT = T.let(T.unsafe(nil), String)

# source://worldwide//lib/worldwide/paths.rb#5
Worldwide::Paths::GEM_ROOT = T.let(T.unsafe(nil), String)

# source://worldwide//lib/worldwide/paths.rb#9
Worldwide::Paths::GENERATED_LOCALE_ROOT = T.let(T.unsafe(nil), String)

# source://worldwide//lib/worldwide/paths.rb#8
Worldwide::Paths::OTHER_DATA_ROOT = T.let(T.unsafe(nil), String)

# source://worldwide//lib/worldwide/paths.rb#11
Worldwide::Paths::REGIONS_ROOT = T.let(T.unsafe(nil), String)

# source://worldwide//lib/worldwide/phone.rb#8
class Worldwide::Phone
  # @return [Phone] a new instance of Phone
  #
  # source://worldwide//lib/worldwide/phone.rb#16
  def initialize(number:, country_code: T.unsafe(nil)); end

  # Return the ISO-3166 alpha-2 code of the country in which this phone number is located
  #
  # source://worldwide//lib/worldwide/phone.rb#23
  def country_code; end

  # Return a formatted number suitable for domestic dialing in the specified country
  #
  # source://worldwide//lib/worldwide/phone.rb#28
  def domestic; end

  # Return the number in E.164 international format
  #
  # source://worldwide//lib/worldwide/phone.rb#33
  def e164; end

  # Returns the value of attribute extension.
  #
  # source://worldwide//lib/worldwide/phone.rb#14
  def extension; end

  # Return a formatted number including the international country code
  #
  # source://worldwide//lib/worldwide/phone.rb#38
  def international; end

  # Return the raw "number" string that was specified when creating this Phone object
  #
  # source://worldwide//lib/worldwide/phone.rb#43
  def raw; end

  # @return [Boolean]
  #
  # source://worldwide//lib/worldwide/phone.rb#47
  def valid?; end

  private

  # source://worldwide//lib/worldwide/phone.rb#76
  def parse_number(number:, country_code:); end

  # Some "country codes" are shared by more than one country.
  # A "domestic" number within this code will be dialable between the included countries,
  # because the namespace is shared, but Phonelib will flag it as "invalid" because it's
  # not within the specified country.  We want to consider any number that is dialable to be valid..
  #
  # source://worldwide//lib/worldwide/phone.rb#106
  def shared_codes; end

  # Split the number into its base (public) number and extension, if any.
  #
  # source://worldwide//lib/worldwide/phone.rb#129
  def split_extension(input); end

  # Convert exotic characters to ASCII
  #
  # source://worldwide//lib/worldwide/phone.rb#146
  def transliterate(number); end

  class << self
    # Returns the value of attribute shared_codes_cache.
    #
    # source://worldwide//lib/worldwide/phone.rb#11
    def shared_codes_cache; end

    # Sets the attribute shared_codes_cache
    #
    # @param value the value to set the attribute shared_codes_cache to.
    #
    # source://worldwide//lib/worldwide/phone.rb#11
    def shared_codes_cache=(_arg0); end
  end
end

# For various reasons, Worldwide considers these territories to be zones inside the USA
# Because libphonenumber considers them to be "countries" in their own right, we must
# add them to the list of "countries" that we'll ask libphonenumber to consider for +1.
#
# source://worldwide//lib/worldwide/phone.rb#56
Worldwide::Phone::NANP_US_TERRITORIES = T.let(T.unsafe(nil), Set)

# libphonenumber does not support certain countries that Worldwide does support.
# If we call Phonelib with one of thes countries, it'll raise an exception.
# Fortunately, both cases are part of the numbering plan of another country, so
# we can simply map to the other country.
#
# source://worldwide//lib/worldwide/phone.rb#69
Worldwide::Phone::UNSUPPORTED_COUNTRIES = T.let(T.unsafe(nil), Hash)

# source://worldwide//lib/worldwide/pluralization_helper.rb#4
module Worldwide::PluralizationHelper
  # Translates pluralization string, returning the first
  # translation found in the `Worldwide::Cldr.fallbacks` chain.
  # Raises I18n::InvalidPluralizationData exception if
  # pluralization data is invalid for all fallbacks.
  #
  # source://worldwide//lib/worldwide/pluralization_helper.rb#9
  def translate_plural(key, count:, locale: T.unsafe(nil)); end

  private

  # Translates pluralization string.
  # Raises I18n::InvalidPluralizationData exception if `raise` is true
  # and pluralization data is invalid.
  #
  # source://worldwide//lib/worldwide/pluralization_helper.rb#22
  def try_translate_plural(key, locale:, count:, raise: T.unsafe(nil)); end
end

# source://worldwide//lib/worldwide/plurals.rb#4
module Worldwide::Plurals
  extend ::Worldwide::Plurals

  # START OF AUTO-GENERATED CONTENT
  # Do not hand-edit this section. It is auto-generated by rake/cldr/locale_generator.rb
  #
  # source://worldwide//lib/worldwide/plurals.rb#28
  def all_cardinal_pluralization_keys; end

  # source://worldwide//lib/worldwide/plurals.rb#32
  def all_ordinal_pluralization_keys; end

  # source://worldwide//lib/worldwide/plurals.rb#11
  def keys(locale, type: T.unsafe(nil)); end

  private

  # END OF AUTO-GENERATED CONTENT
  #
  # source://worldwide//lib/worldwide/plurals.rb#1660
  def cardinal_key_for(locale, n); end

  # source://worldwide//lib/worldwide/plurals.rb#38
  def cardinal_pluralization_keys; end

  # source://worldwide//lib/worldwide/plurals.rb#1669
  def load_locale_rule(locale); end

  # source://worldwide//lib/worldwide/plurals.rb#848
  def ordinal_pluralization_keys; end
end

# source://worldwide//lib/worldwide/plurals.rb#7
class Worldwide::Plurals::UnknownLocaleError < ::StandardError; end

# source://worldwide//lib/worldwide/plurals.rb#9
class Worldwide::Plurals::UnknownPluralizationTypeError < ::StandardError; end

# source://worldwide//lib/worldwide/punctuation.rb#4
class Worldwide::Punctuation
  class << self
    # source://worldwide//lib/worldwide/punctuation.rb#12
    def end_sentence(input, locale: T.unsafe(nil)); end

    # source://worldwide//lib/worldwide/punctuation.rb#6
    def to_paragraph(sentences, locale: T.unsafe(nil)); end

    private

    # source://worldwide//lib/worldwide/punctuation.rb#38
    def base_locale; end

    # The end-of-sentence marker ("period" in American, "full stop" in British English)
    #
    # source://worldwide//lib/worldwide/punctuation.rb#43
    def full_stop; end

    # Strip any number of trailing `terminal_space` characters
    #
    # source://worldwide//lib/worldwide/punctuation.rb#48
    def strip_terminal_spaces(input); end

    # The space that should appear after a full stop, if any.
    #
    # source://worldwide//lib/worldwide/punctuation.rb#57
    def terminal_space; end
  end
end

# source://worldwide//lib/worldwide/region.rb#4
class Worldwide::Region
  # @return [Region] a new instance of Region
  #
  # source://worldwide//lib/worldwide/region.rb#194
  def initialize(alpha_three: T.unsafe(nil), continent: T.unsafe(nil), country: T.unsafe(nil), deprecated: T.unsafe(nil), cldr_code: T.unsafe(nil), iso_code: T.unsafe(nil), legacy_code: T.unsafe(nil), legacy_name: T.unsafe(nil), numeric_three: T.unsafe(nil), province: T.unsafe(nil), short_name: T.unsafe(nil), tax_name: T.unsafe(nil), tax_rate: T.unsafe(nil), use_zone_code_as_short_name: T.unsafe(nil)); end

  # Relationships
  #
  # source://worldwide//lib/worldwide/region.rb#260
  def add_zone(region); end

  # ISO-3166 three-letter code for this region, if there is one.
  # Otherwise, nil.
  #
  # source://worldwide//lib/worldwide/region.rb#43
  def alpha_three; end

  # source://worldwide//lib/worldwide/region.rb#275
  def associated_continent; end

  # Attributes
  #
  # source://worldwide//lib/worldwide/region.rb#269
  def associated_country; end

  # The value with which to autofill the zip, if this region has zip autofill active;
  # otherwise, nil.
  #
  # source://worldwide//lib/worldwide/region.rb#288
  def autofill_zip; end

  # In some countries, an address may have the building number in address2.
  # If we are allowed to have a building number in address2, then this will be true.
  #
  # source://worldwide//lib/worldwide/region.rb#52
  def building_number_may_be_in_address2; end

  # In some countries, an address may have the building number in address2.
  # If we are allowed to have a building number in address2, then this will be true.
  #
  # source://worldwide//lib/worldwide/region.rb#52
  def building_number_may_be_in_address2=(_arg0); end

  # In some countries, every address must have a building number.
  # In others (e.g., GB), some addresses rely on just a building name, not a number.
  # If we require a building number in an address, then this will be true.
  #
  # source://worldwide//lib/worldwide/region.rb#48
  def building_number_required; end

  # In some countries, every address must have a building number.
  # In others (e.g., GB), some addresses rely on just a building name, not a number.
  # If we require a building number in an address, then this will be true.
  #
  # source://worldwide//lib/worldwide/region.rb#48
  def building_number_required=(_arg0); end

  # Does this region require cities to be specified?
  #
  # @return [Boolean]
  #
  # source://worldwide//lib/worldwide/region.rb#293
  def city_required?; end

  # The CLDR code for this region.
  #
  # source://worldwide//lib/worldwide/region.rb#90
  def cldr_code; end

  # Alternate codes which may be used to designate this region
  #
  # source://worldwide//lib/worldwide/region.rb#55
  def code_alternates; end

  # Alternate codes which may be used to designate this region
  #
  # source://worldwide//lib/worldwide/region.rb#55
  def code_alternates=(_arg0); end

  # Is this Region a continent?
  #
  # @return [Boolean]
  #
  # source://worldwide//lib/worldwide/region.rb#298
  def continent?; end

  # Is this Region considered a "country" (top-level political entity "country or region")
  # in the view of the legacy Shopify ecosystem?
  #
  # @return [Boolean]
  #
  # source://worldwide//lib/worldwide/region.rb#304
  def country?; end

  # The suggested currency for use in this region.
  # Note that this may not always be the official currency.
  # E.g., we return USD for VE, not VED.
  #
  # source://worldwide//lib/worldwide/region.rb#60
  def currency; end

  # The suggested currency for use in this region.
  # Note that this may not always be the official currency.
  # E.g., we return USD for VE, not VED.
  #
  # source://worldwide//lib/worldwide/region.rb#60
  def currency=(_arg0); end

  # @return [Boolean]
  #
  # source://worldwide//lib/worldwide/region.rb#308
  def deprecated?; end

  # A major city in the given region that can be used as an example
  #
  # source://worldwide//lib/worldwide/region.rb#63
  def example_city; end

  # A major city in the given region that can be used as an example
  #
  # source://worldwide//lib/worldwide/region.rb#63
  def example_city=(_arg0); end

  # An Worldwide::Field that can be used to ask about the field, including
  # labels, error messages, and an autofill value if there is one.
  #
  # source://worldwide//lib/worldwide/region.rb#314
  def field(key:); end

  # Unicode codepoints for this region's flag emoji
  #
  # source://worldwide//lib/worldwide/region.rb#66
  def flag; end

  # Unicode codepoints for this region's flag emoji
  #
  # source://worldwide//lib/worldwide/region.rb#66
  def flag=(_arg0); end

  # Hash of strings denoting how to format an address in this region.
  # The format is described in https://shopify.engineering/handling-addresses-from-all-around-the-world
  #   - address1: a street address (address line 1, with a buliding nmuber and street name)
  #   - address1_with_unit: address line 1 including a subpremise (unit, apartment, etc.)
  #   - edit: the fields to present on an address input form
  #   - show: how to arrange the fields when formatting an address for display
  #
  # source://worldwide//lib/worldwide/region.rb#74
  def format; end

  # Hash of strings denoting how to format an address in this region.
  # The format is described in https://shopify.engineering/handling-addresses-from-all-around-the-world
  #   - address1: a street address (address line 1, with a buliding nmuber and street name)
  #   - address1_with_unit: address line 1 including a subpremise (unit, apartment, etc.)
  #   - edit: the fields to present on an address input form
  #   - show: how to arrange the fields when formatting an address for display
  #
  # source://worldwide//lib/worldwide/region.rb#74
  def format=(_arg0); end

  # A user-facing name in the currently-active locale's language.
  #
  # source://worldwide//lib/worldwide/region.rb#321
  def full_name(locale: T.unsafe(nil)); end

  # The string that results from appending " Countries" to the adjectival form of the {group_name}
  #
  # @example
  #   CountryDb.country(code: "CA").group == "North American Countries"
  #
  # source://worldwide//lib/worldwide/region.rb#79
  def group; end

  # The string that results from appending " Countries" to the adjectival form of the {group_name}
  #
  # @example
  #   CountryDb.country(code: "CA").group == "North American Countries"
  #
  # source://worldwide//lib/worldwide/region.rb#79
  def group=(_arg0); end

  # The continent that this region is part of.
  #
  # source://worldwide//lib/worldwide/region.rb#82
  def group_name; end

  # The continent that this region is part of.
  #
  # source://worldwide//lib/worldwide/region.rb#82
  def group_name=(_arg0); end

  # Does this region have postal codes?
  #
  # @return [Boolean]
  #
  # source://worldwide//lib/worldwide/region.rb#331
  def has_zip?; end

  # If this flag is set, then we support provinces "under the hood" for this country, but we do not
  # show them as part of a formatted address.  If the province is missing, we will auto-infer it
  # based on the zip (note that this auto-inference may be wrong for some addresses near a border).
  #
  # source://worldwide//lib/worldwide/region.rb#87
  def hide_provinces_from_addresses; end

  # If this flag is set, then we support provinces "under the hood" for this country, but we do not
  # show them as part of a formatted address.  If the province is missing, we will auto-infer it
  # based on the zip (note that this auto-inference may be wrong for some addresses near a border).
  #
  # source://worldwide//lib/worldwide/region.rb#87
  def hide_provinces_from_addresses=(_arg0); end

  # source://worldwide//lib/worldwide/region.rb#254
  def inspect; end

  # The ISO-3166-2 code for this region (e.g. "CA", "CA-ON")
  # or, if there is no alpha-2 code defined for this region, a numeric code (e.g. "001").
  #
  # source://worldwide//lib/worldwide/region.rb#94
  def iso_code; end

  # Languages that are commonly used in this region.
  # Note that this may not be the same as the languages that are officially recognized there.
  # We present them in alphabetical order by language code.
  #
  # source://worldwide//lib/worldwide/region.rb#99
  def languages; end

  # Languages that are commonly used in this region.
  # Note that this may not be the same as the languages that are officially recognized there.
  # We present them in alphabetical order by language code.
  #
  # source://worldwide//lib/worldwide/region.rb#99
  def languages=(_arg0); end

  # The code used by the legacy Shopify ecosystem for this region.
  # E.g., for MX-CMX it will return "DF".
  # This code should _never_ be shown in the user interface.
  # This is the code that was traditionally returned by "country_db".
  #
  # source://worldwide//lib/worldwide/region.rb#105
  def legacy_code; end

  # The name used by the legacy Shopify ecosystem for this region.
  # E.g., "Sao Tome And[sic] Principe" for "ST".
  # This name should _never_ be shown in the user interface.
  # This name is the name that was traditionally returned by "country_db".
  #
  # source://worldwide//lib/worldwide/region.rb#111
  def legacy_name; end

  # Other names that may be used to refer to this region.
  # E.g., "Czech Republic" is also known as "Czechia".
  #
  # source://worldwide//lib/worldwide/region.rb#115
  def name_alternates; end

  # Other names that may be used to refer to this region.
  # E.g., "Czech Republic" is also known as "Czechia".
  #
  # source://worldwide//lib/worldwide/region.rb#115
  def name_alternates=(_arg0); end

  # iso_code values of regions (subdivisions) within the same country that border this region.
  # E.g., for CA-ON, the neighbouring zones are CA-MB, CA-NU and CA-QC.
  #
  # source://worldwide//lib/worldwide/region.rb#119
  def neighbours; end

  # iso_code values of regions (subdivisions) within the same country that border this region.
  # E.g., for CA-ON, the neighbouring zones are CA-MB, CA-NU and CA-QC.
  #
  # source://worldwide//lib/worldwide/region.rb#119
  def neighbours=(_arg0); end

  # The ISO-3166-1 three-digit code for this region (returned as a string to preserve
  # leading zeroes), e.g., "003".
  #
  # source://worldwide//lib/worldwide/region.rb#123
  def numeric_three; end

  # A region may have more than one parent.
  # For example, Puerto Rico (PR/US-PR) is associated with both the US and the Caribbean (029)
  #
  # source://worldwide//lib/worldwide/region.rb#39
  def parents; end

  # A region may have more than one parent.
  # For example, Puerto Rico (PR/US-PR) is associated with both the US and the Caribbean (029)
  #
  # source://worldwide//lib/worldwide/region.rb#39
  def parents=(_arg0); end

  # Some countries have a multi-part postal code, and we may in some cases encounter only the first part.
  # E.g., the GB code `SW1A 1AA` has a first part (outward code) of `SW1A`.
  # When validating such a partial postal code, it must match this regular expression.
  #
  # source://worldwide//lib/worldwide/region.rb#128
  def partial_zip_regex; end

  # Some countries have a multi-part postal code, and we may in some cases encounter only the first part.
  # E.g., the GB code `SW1A 1AA` has a first part (outward code) of `SW1A`.
  # When validating such a partial postal code, it must match this regular expression.
  #
  # source://worldwide//lib/worldwide/region.rb#128
  def partial_zip_regex=(_arg0); end

  # The telephone country dialing code for this region
  #
  # source://worldwide//lib/worldwide/region.rb#131
  def phone_number_prefix; end

  # The telephone country dialing code for this region
  #
  # source://worldwide//lib/worldwide/region.rb#131
  def phone_number_prefix=(_arg0); end

  # Is this Region considered a "province" (political subdivision of a "country")?
  #
  # @return [Boolean]
  #
  # source://worldwide//lib/worldwide/region.rb#336
  def province?; end

  # If true, then the province is optional for addresses in this region.
  #
  # source://worldwide//lib/worldwide/region.rb#192
  def province_optional; end

  # If true, then the province is optional for addresses in this region.
  #
  # source://worldwide//lib/worldwide/region.rb#192
  def province_optional=(_arg0); end

  # are zones optional for this region?
  #
  # @return [Boolean]
  #
  # source://worldwide//lib/worldwide/region.rb#410
  def province_optional?; end

  # A short-form name for this region, if there is a conventional short form.
  # E.g., returns "ON" for "CA-ON", but "Tokyo" for "JP-13".
  #
  # source://worldwide//lib/worldwide/region.rb#342
  def short_name; end

  # tags that help us group the region, e.g. "EU-member"
  #
  # source://worldwide//lib/worldwide/region.rb#149
  def tags; end

  # tags that help us group the region, e.g. "EU-member"
  #
  # source://worldwide//lib/worldwide/region.rb#149
  def tags=(_arg0); end

  # Value Added Tax (Sales Tax) name
  # Note that this should really be translated; showing this untranslated name to users is a bad idea.
  #
  # source://worldwide//lib/worldwide/region.rb#143
  def tax_name; end

  # "generic" VAT tax rate on "most" goods
  #
  # source://worldwide//lib/worldwide/region.rb#146
  def tax_rate; end

  # If the region is within a single timezone, its Olson name will be given here.
  #
  # source://worldwide//lib/worldwide/region.rb#152
  def timezone; end

  # If the region is within a single timezone, its Olson name will be given here.
  #
  # source://worldwide//lib/worldwide/region.rb#152
  def timezone=(_arg0); end

  # If the region spans multiple timezones (and it has postal codes), then this attribute will
  # contain a hash table mapping from timezone name to a list of postal code prefixes.
  # We can use this information to determine the timezone for a given postal code.
  #
  # source://worldwide//lib/worldwide/region.rb#157
  def timezones; end

  # If the region spans multiple timezones (and it has postal codes), then this attribute will
  # contain a hash table mapping from timezone name to a list of postal code prefixes.
  # We can use this information to determine the timezone for a given postal code.
  #
  # source://worldwide//lib/worldwide/region.rb#157
  def timezones=(_arg0); end

  # The measurement system in use in this region.
  #
  # source://worldwide//lib/worldwide/region.rb#164
  def unit_system; end

  # The measurement system in use in this region.
  #
  # source://worldwide//lib/worldwide/region.rb#164
  def unit_system=(_arg0); end

  # true iff zone.iso_code should be returned as the .short_name for zones of this region
  #
  # source://worldwide//lib/worldwide/region.rb#167
  def use_zone_code_as_short_name; end

  # true iff zone.iso_code should be returned as the .short_name for zones of this region
  #
  # source://worldwide//lib/worldwide/region.rb#167
  def use_zone_code_as_short_name=(_arg0); end

  # is the given postal code value valid for this region?
  #
  # @return [Boolean]
  #
  # source://worldwide//lib/worldwide/region.rb#401
  def valid_zip?(zip, partial_match: T.unsafe(nil)); end

  # Day of the week (English language string) on which the week is considered to start in this region.
  # E.g., "sunday"
  #
  # source://worldwide//lib/worldwide/region.rb#161
  def week_start_day; end

  # Day of the week (English language string) on which the week is considered to start in this region.
  # E.g., "sunday"
  #
  # source://worldwide//lib/worldwide/region.rb#161
  def week_start_day=(_arg0); end

  # If the Region has an autofill zip, return the value that will be autofilled
  # Otherwise, return nil
  #
  # source://worldwide//lib/worldwide/region.rb#387
  def zip_autofill; end

  # Some regions have only a single postal code value.
  # In such cases, we can autofill the zip field with the value from zip_example.
  #
  # source://worldwide//lib/worldwide/region.rb#171
  def zip_autofill_enabled; end

  # Some regions have only a single postal code value.
  # In such cases, we can autofill the zip field with the value from zip_example.
  #
  # source://worldwide//lib/worldwide/region.rb#171
  def zip_autofill_enabled=(_arg0); end

  # An example of a valid postal code for this region
  #
  # source://worldwide//lib/worldwide/region.rb#174
  def zip_example; end

  # An example of a valid postal code for this region
  #
  # source://worldwide//lib/worldwide/region.rb#174
  def zip_example=(_arg0); end

  # A list of character sequences with which a postal code in this region may start.
  #
  # source://worldwide//lib/worldwide/region.rb#180
  def zip_prefixes; end

  # A list of character sequences with which a postal code in this region may start.
  #
  # source://worldwide//lib/worldwide/region.rb#180
  def zip_prefixes=(_arg0); end

  # A regular expression which postal codes in this region must match.
  #
  # source://worldwide//lib/worldwide/region.rb#183
  def zip_regex; end

  # A regular expression which postal codes in this region must match.
  #
  # source://worldwide//lib/worldwide/region.rb#183
  def zip_regex=(_arg0); end

  # is a postal code required for this region?
  #
  # @return [Boolean]
  #
  # source://worldwide//lib/worldwide/region.rb#392
  def zip_required?; end

  # Is a zip value required in this region?  (Possible values:  "optional", "recommended", "required")
  #
  # source://worldwide//lib/worldwide/region.rb#177
  def zip_requirement; end

  # Is a zip value required in this region?  (Possible values:  "optional", "recommended", "required")
  #
  # source://worldwide//lib/worldwide/region.rb#177
  def zip_requirement=(_arg0); end

  # Hash of zips that are valid for more than one province
  #
  # source://worldwide//lib/worldwide/region.rb#186
  def zips_crossing_provinces; end

  # Hash of zips that are valid for more than one province
  #
  # source://worldwide//lib/worldwide/region.rb#186
  def zips_crossing_provinces=(_arg0); end

  # returns a Region that is a child of this Region
  #
  # source://worldwide//lib/worldwide/region.rb#347
  def zone(code: T.unsafe(nil), name: T.unsafe(nil), zip: T.unsafe(nil)); end

  # Regions that are sub-regions of this region.
  #
  # source://worldwide//lib/worldwide/region.rb#189
  def zones; end

  private

  # source://worldwide//lib/worldwide/region.rb#416
  def answers_to_cldr_code(search_code); end

  # source://worldwide//lib/worldwide/region.rb#424
  def answers_to_iso_code(search_code); end

  # @return [Boolean]
  #
  # source://worldwide//lib/worldwide/region.rb#431
  def cross_border_zip_includes_province?(zip:, province_code:); end

  # Returns true if this country has zones defined, and has postal code prefix data for the zones
  #
  # @return [Boolean]
  #
  # source://worldwide//lib/worldwide/region.rb#445
  def has_zip_prefixes?; end

  # source://worldwide//lib/worldwide/region.rb#451
  def inspected_fields; end

  # source://worldwide//lib/worldwide/region.rb#455
  def parent_country; end

  # Checks whether the given value is acceptable according to the regular expression defined for the country.
  #
  # @param value [String] for the postal code
  # @return [Boolean]
  #
  # source://worldwide//lib/worldwide/region.rb#462
  def passes_country_zip_regexp?(value:, partial_match: T.unsafe(nil)); end

  # Search a list of zip prefixes (by province or timezone) to find the element that corresponds to the zip
  #
  # prefixes is a hash mapping from Region objects (representing "provinces") to arrays of strings
  # (representing a prefix with which a zip may start for that province), e.g.:
  # {region1 => [prefix1a, prefix1b], region2 => [prefix2a], region3 => [prefix3a, prefix3b, prefix3c]}
  #
  # Returns the Region in which the zip belongs based on the prefix, or `nil` if no match is found.
  #
  # source://worldwide//lib/worldwide/region.rb#484
  def search_prefixes_by_normalized_zip(prefixes:, zip:, allow_partial_zip: T.unsafe(nil)); end

  # source://worldwide//lib/worldwide/region.rb#498
  def subdivision_code(iso_code); end

  # @return [Boolean]
  #
  # source://worldwide//lib/worldwide/region.rb#505
  def valid_normalized_zip?(normalized, province_code: T.unsafe(nil), partial_match: T.unsafe(nil)); end

  # source://worldwide//lib/worldwide/region.rb#538
  def zone_by_normalized_zip(normalized, allow_partial_zip: T.unsafe(nil)); end
end

# The default `.inspect` isn't a good fit for Region, because it can end up dumping a lot of info
# as it walks the hierarchy of descendants.  So, instead, we provide our own `.inspect` that
# only shows a restricted subset of the object's fields.
#
# source://worldwide//lib/worldwide/region.rb#15
Worldwide::Region::INSPECTION_FIELDS = T.let(T.unsafe(nil), Array)

# source://worldwide//lib/worldwide/region.rb#10
Worldwide::Region::OPTIONAL = T.let(T.unsafe(nil), String)

# source://worldwide//lib/worldwide/region.rb#9
Worldwide::Region::RECOMMENDED = T.let(T.unsafe(nil), String)

# When faced with the question, "Is a postal code required in this country?", we treat the answer
# as a tri-state configuration item.  "Recommended" means that we recommend that it be provided,
# but you may still leave the zip field blank.
#
# source://worldwide//lib/worldwide/region.rb#8
Worldwide::Region::REQUIRED = T.let(T.unsafe(nil), String)

# source://worldwide//lib/worldwide/regions.rb#10
class Worldwide::Regions
  include ::Singleton
  extend ::Singleton::SingletonClassMethods

  # @return [Regions] a new instance of Regions
  #
  # source://worldwide//lib/worldwide/regions.rb#18
  def initialize; end

  # source://worldwide//lib/worldwide/regions.rb#22
  def all; end

  # source://worldwide//lib/worldwide/regions.rb#26
  def region(cldr: T.unsafe(nil), code: T.unsafe(nil), name: T.unsafe(nil)); end

  private

  # @return [Boolean]
  #
  # source://worldwide//lib/worldwide/regions.rb#48
  def exactly_one_present?(first, second, third); end

  class << self
    # source://forwardable/1.3.3/forwardable.rb#231
    def all(*args, **_arg1, &block); end

    # source://forwardable/1.3.3/forwardable.rb#231
    def region(*args, **_arg1, &block); end

    # source://forwardable/1.3.3/forwardable.rb#231
    def region_by_cldr_code(*args, **_arg1, &block); end

    private

    def allocate; end
    def new(*_arg0); end
  end
end

# source://worldwide//lib/worldwide/regions_loader.rb#8
class Worldwide::RegionsLoader
  # source://worldwide//lib/worldwide/regions_loader.rb#11
  def load_regions; end

  private

  # source://worldwide//lib/worldwide/regions_loader.rb#64
  def apply_hierarchy(parent:, code:, children:); end

  # source://worldwide//lib/worldwide/regions_loader.rb#91
  def apply_territory_attributes(region, spec); end

  # source://worldwide//lib/worldwide/regions_loader.rb#120
  def apply_zone_attributes(region, zone); end

  # When looking up names in the CLDR data files, we need to use CLDR's naming convention.
  # ISO code CA is CLDR code ca
  # ISO code CA-ON is CLDR code caon
  #
  # source://worldwide//lib/worldwide/regions_loader.rb#131
  def cldr_code(iso_code: T.unsafe(nil), numeric_three: T.unsafe(nil)); end

  # source://worldwide//lib/worldwide/regions_loader.rb#140
  def construct_eu; end

  # source://worldwide//lib/worldwide/regions_loader.rb#40
  def construct_lookup_info(region); end

  # Create trading block regions.
  # Currently only the EU, but we should expand this in the future to cover others like ASEAN and Mercosur
  #
  # source://worldwide//lib/worldwide/regions_loader.rb#169
  def construct_trading_blocks; end

  # source://worldwide//lib/worldwide/regions_loader.rb#173
  def construct_unknown; end

  # @return [Boolean]
  #
  # source://worldwide//lib/worldwide/regions_loader.rb#203
  def continent?(code); end

  # source://worldwide//lib/worldwide/regions_loader.rb#193
  def country_codes; end

  # source://worldwide//lib/worldwide/regions_loader.rb#198
  def find_region(code:); end

  # source://worldwide//lib/worldwide/regions_loader.rb#207
  def load_territory(filename); end

  # source://worldwide//lib/worldwide/regions_loader.rb#243
  def load_zone(region, zone); end

  # source://worldwide//lib/worldwide/regions_loader.rb#278
  def world_yml; end
end

# UN code for the whole world
#
# source://worldwide//lib/worldwide/regions_loader.rb#9
Worldwide::RegionsLoader::WORLD_CODE = T.let(T.unsafe(nil), String)

# source://worldwide//lib/worldwide/ruby_i18n_config.rb#11
class Worldwide::RubyI18nConfig < ::I18n::Config
  # source://worldwide//lib/worldwide/ruby_i18n_config.rb#39
  def available_locales; end

  # source://worldwide//lib/worldwide/ruby_i18n_config.rb#57
  def available_locales=(locales); end

  # @return [Boolean]
  #
  # source://worldwide//lib/worldwide/ruby_i18n_config.rb#63
  def available_locales_initialized?; end

  # Caches the available locales list as both strings and symbols in a Set, so
  # that we can have faster lookups to do the available locales enforce check.
  #
  # source://worldwide//lib/worldwide/ruby_i18n_config.rb#47
  def available_locales_set; end

  # source://worldwide//lib/worldwide/ruby_i18n_config.rb#21
  def backend; end

  # Sets the attribute backend
  #
  # @param value the value to set the attribute backend to.
  #
  # source://worldwide//lib/worldwide/ruby_i18n_config.rb#26
  def backend=(_arg0); end

  # Clears the available locales set so it can be recomputed again after I18n
  # gets reloaded.
  #
  # source://worldwide//lib/worldwide/ruby_i18n_config.rb#71
  def clear_available_locales_set; end

  # source://worldwide//lib/worldwide/ruby_i18n_config.rb#28
  def default_locale; end

  # source://worldwide//lib/worldwide/ruby_i18n_config.rb#34
  def default_locale=(locale); end

  # source://worldwide//lib/worldwide/ruby_i18n_config.rb#75
  def default_separator; end

  # Sets the attribute default_separator
  #
  # @param value the value to set the attribute default_separator to.
  #
  # source://worldwide//lib/worldwide/ruby_i18n_config.rb#80
  def default_separator=(_arg0); end

  # Whether or not to verify if locales are in the list of available locales.
  #
  # source://worldwide//lib/worldwide/ruby_i18n_config.rb#133
  def enforce_available_locales; end

  # Sets the attribute enforce_available_locales
  #
  # @param value the value to set the attribute enforce_available_locales to.
  #
  # source://worldwide//lib/worldwide/ruby_i18n_config.rb#139
  def enforce_available_locales=(_arg0); end

  # source://worldwide//lib/worldwide/ruby_i18n_config.rb#82
  def exception_handler; end

  # Sets the attribute exception_handler
  #
  # @param value the value to set the attribute exception_handler to.
  #
  # source://worldwide//lib/worldwide/ruby_i18n_config.rb#87
  def exception_handler=(_arg0); end

  # source://worldwide//lib/worldwide/ruby_i18n_config.rb#141
  def interpolation_patterns; end

  # Sets the current interpolation patterns. Used to set a interpolation
  # patterns.
  #
  # E.g. using {{}} as a placeholder like "{{hello}}, world!":
  #
  #   I18n.config.interpolation_patterns << /\{\{(\w+)\}\}/
  #
  # source://worldwide//lib/worldwide/ruby_i18n_config.rb#153
  def interpolation_patterns=(_arg0); end

  # Allow clients to register paths providing translation data sources. The
  # backend defines acceptable sources.
  #
  # E.g. the provided SimpleBackend accepts a list of paths to translation
  # files which are either named *.rb and contain plain Ruby Hashes or are
  # named *.yml and contain YAML data. So for the SimpleBackend clients may
  # register translation files like this:
  #   I18n.load_path << 'path/to/locale/en.yml'
  #
  # source://worldwide//lib/worldwide/ruby_i18n_config.rb#118
  def load_path; end

  # Sets the load path instance. Custom implementations are expected to
  # behave like a Ruby Array.
  #
  # source://worldwide//lib/worldwide/ruby_i18n_config.rb#126
  def load_path=(load_path); end

  # source://worldwide//lib/worldwide/ruby_i18n_config.rb#12
  def locale; end

  # source://worldwide//lib/worldwide/ruby_i18n_config.rb#16
  def locale=(locale); end

  # Returns the current handler for situations when interpolation argument
  # is missing. MissingInterpolationArgument will be raised by default.
  #
  # source://worldwide//lib/worldwide/ruby_i18n_config.rb#91
  def missing_interpolation_argument_handler; end

  # Sets the missing interpolation argument handler. It can be any
  # object that responds to #call. The arguments that will be passed to #call
  # are the same as for MissingInterpolationArgument initializer. Use +Proc.new+
  # if you don't care about arity.
  #
  # == Example:
  # You can supress raising an exception and return string instead:
  #
  #   I18n.config.missing_interpolation_argument_handler = Proc.new do |key|
  #     "#{key} is missing"
  #   end
  #
  # source://worldwide//lib/worldwide/ruby_i18n_config.rb#108
  def missing_interpolation_argument_handler=(_arg0); end
end

# source://worldwide//lib/worldwide/units.rb#4
Worldwide::SUPPORTED_HUMANIZATIONS = T.let(T.unsafe(nil), Hash)

# source://worldwide//lib/worldwide/scripts.rb#4
module Worldwide::Scripts
  class << self
    # Based off of the text provided, method will return the scripts identified
    #
    # source://worldwide//lib/worldwide/scripts.rb#7
    def identify(text:); end
  end
end

# source://worldwide//lib/worldwide/time_formatter.rb#4
class Worldwide::TimeFormatter
  # @return [TimeFormatter] a new instance of TimeFormatter
  #
  # source://worldwide//lib/worldwide/time_formatter.rb#5
  def initialize(locale: T.unsafe(nil)); end

  # source://worldwide//lib/worldwide/time_formatter.rb#9
  def hour_minute_separator; end

  # @return [Boolean]
  #
  # source://worldwide//lib/worldwide/time_formatter.rb#14
  def twelve_hour_clock?; end
end

# source://worldwide//lib/worldwide/time_zone.rb#4
class Worldwide::TimeZone
  # @return [TimeZone] a new instance of TimeZone
  #
  # source://worldwide//lib/worldwide/time_zone.rb#21
  def initialize(name); end

  # Returns the value of attribute name.
  #
  # source://worldwide//lib/worldwide/time_zone.rb#19
  def name; end

  # source://worldwide//lib/worldwide/time_zone.rb#25
  def to_s; end

  private

  # source://worldwide//lib/worldwide/time_zone.rb#31
  def translated_name; end

  class << self
    # source://worldwide//lib/worldwide/time_zone.rb#6
    def all; end

    private

    # source://worldwide//lib/worldwide/time_zone.rb#12
    def uniq_zone_names; end
  end
end

# source://worldwide//lib/worldwide/units.rb#56
class Worldwide::Units
  class << self
    # @raise [ArgumentError]
    #
    # source://worldwide//lib/worldwide/units.rb#58
    def format(amount, unit, humanize: T.unsafe(nil)); end
  end
end

# source://worldwide//lib/worldwide/util.rb#4
class Worldwide::Util
  class << self
    # @return [Boolean]
    #
    # source://worldwide//lib/worldwide/util.rb#6
    def blank?(value); end

    # @return [Boolean]
    #
    # source://worldwide//lib/worldwide/util.rb#12
    def present?(value); end
  end
end

# source://worldwide//lib/worldwide/version.rb#4
Worldwide::VERSION = T.let(T.unsafe(nil), String)

# source://worldwide//lib/worldwide/zip.rb#4
module Worldwide::Zip
  extend ::Worldwide::Zip

  # Suggest a country for a given postal code.
  #
  # Some countries have an ambiguous dual state.  For example, some consider Jersey to be a
  # top-level country in its own right, while others consider it to be part of the United Kingdom.
  # This leads to frustrated buyers receiving a validation error when they enter their address
  # and the postal code isn't valid for the selected "country".
  #
  # Also, in some cases, users are simply confused, and use a postal code that is obviously
  # inappropriate for the selected country.  Some examples:
  #   - entering a postal code for Georgia, United States, but selecting the country Georgia
  #   - using a USA FPO address, but selecting the non-US physical location of the US base as the country
  #
  # This method attempts to heuristically suggest a country in some common cases where we see
  # a lot of confusion.  There's no way to solve this problem for all cases, and we will often
  # not have a suggestion (in which case this method will return `nil`).
  #
  # @param country_code [String] The country code that the user thought this postal code was for (optional)
  # @param zip [String] The postal code that the user entered (required)
  # @param min_confidence [Integer] The minimum confidence level (between 0-100) that is accepted from a suggestion (optional)
  # @return [Region] which is a "country" if we have a suggestion, or `nil` if we do not.
  #
  # source://worldwide//lib/worldwide/zip.rb#52
  def find_country(zip:, country_code: T.unsafe(nil), min_confidence: T.unsafe(nil)); end

  # The United Kingdom has an unusual style of postcode.
  # It consists of two halves (outcode and incode), separated by a space.
  # The incode is always 3 characters, with 1 digit followed by 2 letters.
  # The outcode varies from 2 to 4 characters, following certain patterns.
  # A handful of other countries also allocate their codes within the UK "namespace".
  #
  # @return [Boolean]
  #
  # source://worldwide//lib/worldwide/zip.rb#28
  def gb_style?(country_code:); end

  # Normalizes the postal code into the format expected by the national postal authority.
  #
  # @param country_code [String] The country in which this postal code is located.
  # @param zip [String] The postal code as the user has entered it.
  # @param allow_autofill [String] Normalize the postal code for the candidate country prior to seeing whether the regular expression matches that (normalized) code.
  # @param strip_extraneous_characters [String] Allow additional stripping of characters to either fully numeric or alphanumeric depending on the country.
  # @return [String] The postal code with spaces inserted/removed and other formatting fixes applied.
  #
  # source://worldwide//lib/worldwide/zip.rb#85
  def normalize(country_code:, zip:, allow_autofill: T.unsafe(nil), strip_extraneous_characters: T.unsafe(nil)); end

  # We want to show numeric keypad on mobile view for countries with only numeric postal codes
  # Spaces or dashes are allowed.
  #
  # @return [Boolean] true or false depending on whether postal code can contain only digits or not.
  #
  # source://worldwide//lib/worldwide/zip.rb#10
  def numeric_only_zip?(country_code:); end

  # Returns the "outcode" (first portion) of a postcode for a country that uses the UK style.
  # Returns the "forward sortation area" (first portion) of a postal code for Canada.
  # Returns the "routing key" (first portion) of a postal code for Ireland.
  # Otherwise, returns the full zip.
  #
  # source://worldwide//lib/worldwide/zip.rb#157
  def outcode(country_code:, zip:); end

  # We want to show numeric keypad on mobile view for countries with only numeric postal codes
  # Spaces or dashes aren't allowed.
  #
  # @return [Boolean] true or false depending on whether postal code can contain only digits or not.
  #
  # source://worldwide//lib/worldwide/zip.rb#17
  def pure_numeric_only_zip?(country_code:); end

  # source://worldwide//lib/worldwide/zip.rb#165
  def strip_optional_country_prefix(country_code:, zip:); end

  private

  # source://worldwide//lib/worldwide/zip.rb#498
  def add_prefix_if_required(country_code:, zip:); end

  # source://worldwide//lib/worldwide/zip.rb#507
  def find_country_using_alleged_country(country_code, zip); end

  # source://worldwide//lib/worldwide/zip.rb#521
  def find_country_using_zip_alone(zip); end

  # source://worldwide//lib/worldwide/zip.rb#538
  def insert_spaces_and_hyphens(country_code:, zip:); end

  # source://worldwide//lib/worldwide/zip.rb#550
  def insert_spaces_and_hyphens_for_partial_code(country_code:, zip:); end

  # source://worldwide//lib/worldwide/zip.rb#729
  def normalize_for_bd(zip:); end

  # Users have a habit of entering the 3-digit postal code for Faroe Islands with an extraneous 0 prefix
  # This is not permitted by the FO postal service, but is predictable enough that we can auto-correct it.
  #
  # source://worldwide//lib/worldwide/zip.rb#742
  def normalize_for_fo(zip:); end

  # zip should be stripped of spaces, converted full-width to half-width, and upcased before we call this function
  #
  # source://worldwide//lib/worldwide/zip.rb#756
  def normalize_for_gb(zip:); end

  # GhanaPostGPS codes may be any of
  #   AX
  #   AX-111
  #   AX-1111
  #   AX-111-1111
  #   AX-1111-1111
  # where
  #   A is a letter
  #   X is a letter or a digit
  #   1 is a digit
  #
  # source://worldwide//lib/worldwide/zip.rb#803
  def normalize_for_gh(zip:); end

  # A non-trivial number of buyers in HT seem to write their postcode as
  # xxxxHT, when the official format is HTxxxx.
  #
  # source://worldwide//lib/worldwide/zip.rb#819
  def normalize_for_ht(zip:); end

  # Certain "mistakes" are common in Sri Lanka
  #   - codes in Colombo are often given in old "sorting code" style, "02" or "002" instead of "00200"
  #   - codes ending in four zeroes often drop one of them, "4000" instead of "40000"
  #
  # source://worldwide//lib/worldwide/zip.rb#833
  def normalize_for_lk(zip:); end

  # In Morocco, many of the most-frequently-used postcodes end in a long string of zeroes.
  # Users frequently get confused about how many zeroes there should be, and either leave one out
  # or insert an extra one.
  # So, for example, we see addresses in Casablanca, whose postcode is 20000, with postcode 2000.
  # To reduce friction during checkout, we auto-correct these.
  #
  # source://worldwide//lib/worldwide/zip.rb#1068
  def normalize_for_ma(zip:); end

  # Moldova post prefers codes to be written "MD-nnnn", but some folks seem to be writing them
  # nnnnMD.  Let's rewrite those so that they'll be accepted.
  #
  # source://worldwide//lib/worldwide/zip.rb#851
  def normalize_for_md(zip:); end

  # MG postcodes are only 3 digits, but some users zip them with two leading zeroes.
  #
  # source://worldwide//lib/worldwide/zip.rb#863
  def normalize_for_mg(zip:); end

  # In Nigeria, several commonly-used postcodes are of the form "n00001".
  # (This is the main post office of a major centre.)
  # We often see users mistype those as either "n0001" or "n000001".
  # Looking at the rest of the address records when that happens, we are reasonably confident that we can
  # auto-correct those particular codes.
  #
  # source://worldwide//lib/worldwide/zip.rb#879
  def normalize_for_ng(zip:); end

  # Users in SG do a couple of odd things:
  #  - add `S` or `5` in front of the code; we should remove this if it's present
  #  - add `SINGAPORE` either before or after the code; we should remove this if it's present
  #
  # source://worldwide//lib/worldwide/zip.rb#893
  def normalize_for_sg(zip:); end

  # Several common Kosovo codes have long strings of zeroes.
  # Users frequently have either one extra zero, or one zero missing.
  # We can help them out by autocorrecting those.
  #
  # source://worldwide//lib/worldwide/zip.rb#1083
  def normalize_for_xk(zip:); end

  # source://worldwide//lib/worldwide/zip.rb#1057
  def regex_for(country_code); end

  # source://worldwide//lib/worldwide/zip.rb#584
  def replace_letters_and_numbers(country_code:, zip:); end

  # source://worldwide//lib/worldwide/zip.rb#602
  def replace_letters_and_numbers_for_alphanumeric(country_code:, zip:); end

  # source://worldwide//lib/worldwide/zip.rb#664
  def replace_ohs_and_zeros_for_bm(zip:); end

  # source://worldwide//lib/worldwide/zip.rb#682
  def replace_ohs_and_zeros_for_gb(zip:); end

  # source://worldwide//lib/worldwide/zip.rb#562
  def replace_where_eircode_char_is_expected(zip:, country_code: T.unsafe(nil)); end

  # source://worldwide//lib/worldwide/zip.rb#575
  def replace_where_letter_is_expected(zip:, country_code: T.unsafe(nil)); end

  # source://worldwide//lib/worldwide/zip.rb#566
  def replace_where_number_is_expected(zip:, country_code: T.unsafe(nil)); end

  # source://worldwide//lib/worldwide/zip.rb#1094
  def strip_extraneous_characters(zip:, country_code:); end

  # For a given country, a list of alternative countries that we might suggest, and the
  # regular expression that should match in order to make that suggestion.
  #
  # source://worldwide//lib/worldwide/zip.rb#910
  def zips_for_country; end
end

# Countries with alphanumeric postal codes
# This mapping is in the format (country_code) => [possible_zip_format]
# The possible postal code format does not include any spaces of hyphens
# A represents where we expect to see a letter
# 1 represents where we expect to see a number
# E represents where we expect either a number or an Eircode-permitted letter
# ? represents where we expect to see a letter or a number
#
# source://worldwide//lib/worldwide/zip.rb#217
Worldwide::Zip::ALPHNUMERIC_POSTAL_CODE_FORMATS = T.let(T.unsafe(nil), Hash)

# source://worldwide//lib/worldwide/zip.rb#234
Worldwide::Zip::EIRCODE_CHAR_MAPPING = T.let(T.unsafe(nil), Hash)

# CO, PO, SO, YO
# SO and postal town S (Sheffield) both don't have a district 0 so it can be checked correctly
#
# source://worldwide//lib/worldwide/zip.rb#348
Worldwide::Zip::GB_POSTAL_TOWN_WITH_SECOND_CHAR_OH = T.let(T.unsafe(nil), Array)

# Countries that use GB-style postal code spacing, and should normalize the same way as GB
#
# source://worldwide//lib/worldwide/zip.rb#199
Worldwide::Zip::GB_STYLE_ZIP_COUNTRIES = T.let(T.unsafe(nil), Array)

# TODO(on: date('2022-07-01'), to: '#address-service')
# A plus customer in Costa Rica has customized their address form to put the city value in the zip field.
# To avoid impacting their holiday-season sales, we are temporarily disabling normaliziton for zip for CR.
# The intention is to remove this special case (start normalizing again) in 2022.
#
# source://worldwide//lib/worldwide/zip.rb#206
Worldwide::Zip::NORMALIZATION_DISABLED_COUNTRIES = T.let(T.unsafe(nil), Array)

# Based on postal code formats here: https://en.wikipedia.org/wiki/List_of_postal_codes
#
# source://worldwide//lib/worldwide/zip.rb#352
Worldwide::Zip::NUMERIC_ONLY_ZIP_COUNTRIES = T.let(T.unsafe(nil), Set)

# Most European countries have an optional prefix that denotes to which country the postal code applies.
# This may use the ISO country code, or the car number plate code.
# For example, the Reichstag in Berlin's postal code may be written "11011", "DE-11011" or "D-11011".
# We must strip that prefix before trying to look up the zone based on the remaining prefix.
#
# source://worldwide//lib/worldwide/zip.rb#251
Worldwide::Zip::OPTIONAL_PREFIX_COUNTRIES = T.let(T.unsafe(nil), Hash)

# source://worldwide//lib/worldwide/zip.rb#290
Worldwide::Zip::REQUIRED_PREFIX_COUNTRIES = T.let(T.unsafe(nil), Hash)

# Some countries have spaces and/or hyphens in their postal codes.
# We strip all spaces and hyphens before normalizing, and then put them back only in the spots where they are expected.
# This mapping is in the format (country_code) => [number_of_characters, character_to_insert, position]
#
# source://worldwide//lib/worldwide/zip.rb#298
Worldwide::Zip::SPACES_AND_HYPHENS = T.let(T.unsafe(nil), Hash)
