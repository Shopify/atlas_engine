# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `job-iteration` gem.
# Please instead update this file by running `bin/tapioca gem job-iteration`.

# source://job-iteration//lib/job-iteration/version.rb#3
module JobIteration
  extend ::JobIteration

  # Configures a delay duration to wait before resuming an interrupted job.
  # Defaults to nil which means interrupted jobs will be retried immediately.
  # This value will be ignored when an interruption is raised by a throttle enumerator,
  # where the throttle backoff value will take precedence over this setting.
  #
  # @example
  #
  #   JobIteration.default_retry_backoff = 10.seconds
  #
  # source://job-iteration//lib/job-iteration.rb#50
  def default_retry_backoff; end

  # Configures a delay duration to wait before resuming an interrupted job.
  # Defaults to nil which means interrupted jobs will be retried immediately.
  # This value will be ignored when an interruption is raised by a throttle enumerator,
  # where the throttle backoff value will take precedence over this setting.
  #
  # @example
  #
  #   JobIteration.default_retry_backoff = 10.seconds
  #
  # source://job-iteration//lib/job-iteration.rb#50
  def default_retry_backoff=(_arg0); end

  # Set if you want to use your own enumerator builder instead of default EnumeratorBuilder.
  #
  # @example
  #
  #   class MyOwnBuilder < JobIteration::EnumeratorBuilder
  #   # ...
  #   end
  #
  #   JobIteration.enumerator_builder = MyOwnBuilder
  #
  # source://job-iteration//lib/job-iteration.rb#65
  def enumerator_builder; end

  # Set if you want to use your own enumerator builder instead of default EnumeratorBuilder.
  #
  # @example
  #
  #   class MyOwnBuilder < JobIteration::EnumeratorBuilder
  #   # ...
  #   end
  #
  #   JobIteration.enumerator_builder = MyOwnBuilder
  #
  # source://job-iteration//lib/job-iteration.rb#65
  def enumerator_builder=(_arg0); end

  # Used internally for hooking into job processing frameworks like Sidekiq and Resque.
  #
  # source://job-iteration//lib/job-iteration.rb#53
  def interruption_adapter; end

  # Used internally for hooking into job processing frameworks like Sidekiq and Resque.
  #
  # source://job-iteration//lib/job-iteration.rb#53
  def interruption_adapter=(_arg0); end

  # source://job-iteration//lib/job-iteration.rb#83
  def load_integration(integration); end

  # source://job-iteration//lib/job-iteration.rb#69
  def load_integrations; end

  # Sets the attribute logger
  #
  # @param value the value to set the attribute logger to.
  #
  # source://job-iteration//lib/job-iteration.rb#16
  def logger=(_arg0); end

  # Use this to _always_ interrupt the job after it's been running for more than N seconds.
  # This setting will make it to always interrupt a job after it's been iterating for 5 minutes.
  # Defaults to nil which means that jobs will not be interrupted except on termination signal.
  #
  # This setting can be further reduced (but not increased) by using the inheritable per-class
  # job_iteration_max_job_runtime setting.
  #
  # @example
  #
  #   JobIteration.max_job_runtime = 5.minutes
  # @example
  #
  #   class MyJob < ActiveJob::Base
  #   include JobIteration::Iteration
  #   self.job_iteration_max_job_runtime = 1.minute
  #   # ...
  #
  # source://job-iteration//lib/job-iteration.rb#40
  def max_job_runtime; end

  # Use this to _always_ interrupt the job after it's been running for more than N seconds.
  # This setting will make it to always interrupt a job after it's been iterating for 5 minutes.
  # Defaults to nil which means that jobs will not be interrupted except on termination signal.
  #
  # This setting can be further reduced (but not increased) by using the inheritable per-class
  # job_iteration_max_job_runtime setting.
  #
  # @example
  #
  #   JobIteration.max_job_runtime = 5.minutes
  # @example
  #
  #   class MyJob < ActiveJob::Base
  #   include JobIteration::Iteration
  #   self.job_iteration_max_job_runtime = 1.minute
  #   # ...
  #
  # source://job-iteration//lib/job-iteration.rb#40
  def max_job_runtime=(_arg0); end

  class << self
    # source://job-iteration//lib/job-iteration.rb#19
    def logger; end
  end
end

# Builds Batch Enumerator based on ActiveRecord Relation.
#
# @see EnumeratorBuilder
#
# source://job-iteration//lib/job-iteration/active_record_batch_enumerator.rb#6
class JobIteration::ActiveRecordBatchEnumerator
  include ::Enumerable

  # @raise [ArgumentError]
  # @return [ActiveRecordBatchEnumerator] a new instance of ActiveRecordBatchEnumerator
  #
  # source://job-iteration//lib/job-iteration/active_record_batch_enumerator.rb#11
  def initialize(relation, columns: T.unsafe(nil), batch_size: T.unsafe(nil), cursor: T.unsafe(nil)); end

  # source://job-iteration//lib/job-iteration/active_record_batch_enumerator.rb#35
  def each; end

  # source://job-iteration//lib/job-iteration/active_record_batch_enumerator.rb#43
  def size; end

  private

  # source://job-iteration//lib/job-iteration/active_record_batch_enumerator.rb#116
  def column_value(value); end

  # source://job-iteration//lib/job-iteration/active_record_batch_enumerator.rb#94
  def conditions; end

  # source://job-iteration//lib/job-iteration/active_record_batch_enumerator.rb#88
  def cursor_value; end

  # source://job-iteration//lib/job-iteration/active_record_batch_enumerator.rb#49
  def next_batch; end

  # source://job-iteration//lib/job-iteration/active_record_batch_enumerator.rb#74
  def pluck_columns(relation); end

  # source://job-iteration//lib/job-iteration/active_record_batch_enumerator.rb#112
  def serialize_column_values!(column_values); end
end

# source://job-iteration//lib/job-iteration/active_record_batch_enumerator.rb#9
JobIteration::ActiveRecordBatchEnumerator::SQL_DATETIME_WITH_NSEC = T.let(T.unsafe(nil), String)

# Curious about how this works from the SQL perspective?
# Check "Pagination Done the Right way": https://bit.ly/2Rq7iPF
#
# source://job-iteration//lib/job-iteration/active_record_cursor.rb#6
class JobIteration::ActiveRecordCursor
  include ::Comparable

  # @raise [ArgumentError]
  # @return [ActiveRecordCursor] a new instance of ActiveRecordCursor
  #
  # source://job-iteration//lib/job-iteration/active_record_cursor.rb#21
  def initialize(relation, columns = T.unsafe(nil), position = T.unsafe(nil)); end

  # source://job-iteration//lib/job-iteration/active_record_cursor.rb#41
  def <=>(other); end

  # source://job-iteration//lib/job-iteration/active_record_cursor.rb#62
  def next_batch(batch_size); end

  # Returns the value of attribute position.
  #
  # source://job-iteration//lib/job-iteration/active_record_cursor.rb#9
  def position; end

  # source://job-iteration//lib/job-iteration/active_record_cursor.rb#49
  def position=(position); end

  # Returns the value of attribute reached_end.
  #
  # source://job-iteration//lib/job-iteration/active_record_cursor.rb#10
  def reached_end; end

  # Sets the attribute reached_end
  #
  # @param value the value to set the attribute reached_end to.
  #
  # source://job-iteration//lib/job-iteration/active_record_cursor.rb#10
  def reached_end=(_arg0); end

  # source://job-iteration//lib/job-iteration/active_record_cursor.rb#55
  def update_from_record(record); end

  protected

  # source://job-iteration//lib/job-iteration/active_record_cursor.rb#83
  def conditions; end
end

# source://job-iteration//lib/job-iteration/active_record_cursor.rb#12
class JobIteration::ActiveRecordCursor::ConditionNotSupportedError < ::ArgumentError
  # @return [ConditionNotSupportedError] a new instance of ConditionNotSupportedError
  #
  # source://job-iteration//lib/job-iteration/active_record_cursor.rb#13
  def initialize; end
end

# Builds Enumerator based on ActiveRecord Relation. Supports enumerating on rows and batches.
#
# @see EnumeratorBuilder
#
# source://job-iteration//lib/job-iteration/active_record_enumerator.rb#7
class JobIteration::ActiveRecordEnumerator
  # @return [ActiveRecordEnumerator] a new instance of ActiveRecordEnumerator
  #
  # source://job-iteration//lib/job-iteration/active_record_enumerator.rb#10
  def initialize(relation, columns: T.unsafe(nil), batch_size: T.unsafe(nil), cursor: T.unsafe(nil)); end

  # source://job-iteration//lib/job-iteration/active_record_enumerator.rb#31
  def batches; end

  # source://job-iteration//lib/job-iteration/active_record_enumerator.rb#21
  def records; end

  # source://job-iteration//lib/job-iteration/active_record_enumerator.rb#40
  def size; end

  private

  # source://job-iteration//lib/job-iteration/active_record_enumerator.rb#60
  def column_value(record, attribute); end

  # source://job-iteration//lib/job-iteration/active_record_enumerator.rb#46
  def cursor_value(record); end

  # source://job-iteration//lib/job-iteration/active_record_enumerator.rb#56
  def finder_cursor; end
end

# source://job-iteration//lib/job-iteration/active_record_enumerator.rb#8
JobIteration::ActiveRecordEnumerator::SQL_DATETIME_WITH_NSEC = T.let(T.unsafe(nil), String)

# CsvEnumerator makes it possible to write an Iteration job
# that uses CSV file as a collection to Iterate.
#
# @example
#   def build_enumerator(cursor:)
#   csv = CSV.open('tmp/files', { converters: :integer, headers: true })
#   JobIteration::CsvEnumerator.new(csv).rows(cursor: cursor)
#   end
#
#   def each_iteration(row)
#   ...
#   end
#
# source://job-iteration//lib/job-iteration/csv_enumerator.rb#15
class JobIteration::CsvEnumerator
  # Constructs CsvEnumerator instance based on a CSV file.
  #
  # @example
  #   csv = CSV.open('tmp/files', { converters: :integer, headers: true })
  #   JobIteration::CsvEnumerator.new(csv).rows(cursor: cursor)
  # @param csv [CSV] An instance of CSV object
  # @return [JobIteration::CsvEnumerator]
  #
  # source://job-iteration//lib/job-iteration/csv_enumerator.rb#22
  def initialize(csv); end

  # Constructs a enumerator on batches of CSV rows
  #
  # @return [Enumerator] Enumerator instance
  #
  # source://job-iteration//lib/job-iteration/csv_enumerator.rb#41
  def batches(batch_size:, cursor:); end

  # Constructs a enumerator on CSV rows
  #
  # @return [Enumerator] Enumerator instance
  #
  # source://job-iteration//lib/job-iteration/csv_enumerator.rb#32
  def rows(cursor:); end

  private

  # source://job-iteration//lib/job-iteration/csv_enumerator.rb#67
  def count_of_processed_rows(cursor); end

  # source://job-iteration//lib/job-iteration/csv_enumerator.rb#51
  def count_of_rows_in_file; end
end

# source://job-iteration//lib/job-iteration/enumerator_builder.rb#11
class JobIteration::EnumeratorBuilder
  extend ::Forwardable

  # @return [EnumeratorBuilder] a new instance of EnumeratorBuilder
  #
  # source://job-iteration//lib/job-iteration/enumerator_builder.rb#34
  def initialize(job, wrapper: T.unsafe(nil)); end

  # Builds Enumerator from Active Record Relation and enumerates on batches, yielding Active Record Relations.
  # See documentation for #build_active_record_enumerator_on_batches.
  #
  # source://job-iteration//lib/job-iteration/enumerator_builder.rb#127
  def active_record_on_batch_relations(scope, cursor:, wrap: T.unsafe(nil), **args); end

  # Builds Enumerator from Active Record Relation and enumerates on batches of records.
  # Each Enumerator tick moves the cursor +batch_size+ rows forward.
  #
  # +batch_size:+ sets how many records will be fetched in one batch. Defaults to 100.
  #
  # For the rest of arguments, see documentation for #build_active_record_enumerator_on_records
  #
  # source://job-iteration//lib/job-iteration/enumerator_builder.rb#116
  def active_record_on_batches(scope, cursor:, **args); end

  # Builds Enumerator from Active Record Relation. Each Enumerator tick moves the cursor one row forward.
  #
  # +columns:+ argument is used to build the actual query for iteration. +columns+: defaults to primary key:
  #
  #   1) SELECT * FROM users ORDER BY id LIMIT 100
  #
  # When iteration is resumed, +cursor:+ and +columns:+ values will be used to continue from the point
  # where iteration stopped:
  #
  #   2) SELECT * FROM users WHERE id > $CURSOR ORDER BY id LIMIT 100
  #
  # +columns:+ can also take more than one column. In that case, +cursor+ will contain serialized values
  # of all columns at the point where iteration stopped.
  #
  # Consider this example with +columns: [:created_at, :id]+. Here's the query will use on the first iteration:
  #
  #   1) SELECT * FROM `products` ORDER BY created_at, id LIMIT 100
  #
  # And the query on the next iteration:
  #
  #   2) SELECT * FROM `products`
  #        WHERE (created_at > '$LAST_CREATED_AT_CURSOR'
  #          OR (created_at = '$LAST_CREATED_AT_CURSOR' AND (id > '$LAST_ID_CURSOR')))
  #        ORDER BY created_at, id LIMIT 100
  #
  # As a result of this query pattern, if the values in these columns change for the records in scope during
  # iteration, they may be skipped or yielded multiple times depending on the nature of the update and the
  # cursor's value. If the value gets updated to a greater value than the cursor's value, it will get yielded
  # again. Similarly, if the value gets updated to a lesser value than the curor's value, it will get skipped.
  #
  # source://job-iteration//lib/job-iteration/enumerator_builder.rb#101
  def active_record_on_records(scope, cursor:, **args); end

  # Builds Enumerator object from a given array, using +cursor+ as an offset.
  #
  # source://job-iteration//lib/job-iteration/enumerator_builder.rb#54
  def array(enumerable, cursor:); end

  # Builds Enumerator from Active Record Relation and enumerates on batches, yielding Active Record Relations.
  # See documentation for #build_active_record_enumerator_on_batches.
  #
  # source://job-iteration//lib/job-iteration/enumerator_builder.rb#127
  def build_active_record_enumerator_on_batch_relations(scope, cursor:, wrap: T.unsafe(nil), **args); end

  # Builds Enumerator from Active Record Relation and enumerates on batches of records.
  # Each Enumerator tick moves the cursor +batch_size+ rows forward.
  #
  # +batch_size:+ sets how many records will be fetched in one batch. Defaults to 100.
  #
  # For the rest of arguments, see documentation for #build_active_record_enumerator_on_records
  #
  # source://job-iteration//lib/job-iteration/enumerator_builder.rb#116
  def build_active_record_enumerator_on_batches(scope, cursor:, **args); end

  # Builds Enumerator from Active Record Relation. Each Enumerator tick moves the cursor one row forward.
  #
  # +columns:+ argument is used to build the actual query for iteration. +columns+: defaults to primary key:
  #
  #   1) SELECT * FROM users ORDER BY id LIMIT 100
  #
  # When iteration is resumed, +cursor:+ and +columns:+ values will be used to continue from the point
  # where iteration stopped:
  #
  #   2) SELECT * FROM users WHERE id > $CURSOR ORDER BY id LIMIT 100
  #
  # +columns:+ can also take more than one column. In that case, +cursor+ will contain serialized values
  # of all columns at the point where iteration stopped.
  #
  # Consider this example with +columns: [:created_at, :id]+. Here's the query will use on the first iteration:
  #
  #   1) SELECT * FROM `products` ORDER BY created_at, id LIMIT 100
  #
  # And the query on the next iteration:
  #
  #   2) SELECT * FROM `products`
  #        WHERE (created_at > '$LAST_CREATED_AT_CURSOR'
  #          OR (created_at = '$LAST_CREATED_AT_CURSOR' AND (id > '$LAST_ID_CURSOR')))
  #        ORDER BY created_at, id LIMIT 100
  #
  # As a result of this query pattern, if the values in these columns change for the records in scope during
  # iteration, they may be skipped or yielded multiple times depending on the nature of the update and the
  # cursor's value. If the value gets updated to a greater value than the cursor's value, it will get yielded
  # again. Similarly, if the value gets updated to a lesser value than the curor's value, it will get skipped.
  #
  # source://job-iteration//lib/job-iteration/enumerator_builder.rb#101
  def build_active_record_enumerator_on_records(scope, cursor:, **args); end

  # Builds Enumerator object from a given array, using +cursor+ as an offset.
  #
  # source://job-iteration//lib/job-iteration/enumerator_builder.rb#54
  def build_array_enumerator(enumerable, cursor:); end

  # source://job-iteration//lib/job-iteration/enumerator_builder.rb#146
  def build_csv_enumerator(enumerable, cursor:); end

  # Builds Enumerator for nested iteration.
  #
  # @example
  #   def build_enumerator(cursor:)
  #   enumerator_builder.nested(
  #   [
  #   ->(cursor) {
  #   enumerator_builder.active_record_on_records(Shop.all, cursor: cursor)
  #   },
  #   ->(shop, cursor) {
  #   enumerator_builder.active_record_on_records(shop.products, cursor: cursor)
  #   },
  #   ->(_shop, product, cursor) {
  #   enumerator_builder.active_record_on_batch_relations(product.product_variants, cursor: cursor)
  #   }
  #   ],
  #   cursor: cursor
  #   )
  #   end
  #
  #   def each_iteration(product_variants_relation)
  #   # do something
  #   end
  # @param enums [Array<Proc>] an Array of Procs, each should return an Enumerator.
  #   Each proc from enums should accept the yielded items from the parent enumerators
  #   and the `cursor` as its arguments.
  #   Each proc's `cursor` argument is its part from the `build_enumerator`'s `cursor` array.
  # @param cursor [Array<Object>] array of offsets for each of the enums to start iteration from
  #
  # source://job-iteration//lib/job-iteration/enumerator_builder.rb#180
  def build_nested_enumerator(enums, cursor:); end

  # Builds Enumerator objects that iterates once.
  #
  # source://job-iteration//lib/job-iteration/enumerator_builder.rb#42
  def build_once_enumerator(cursor:); end

  # source://job-iteration//lib/job-iteration/enumerator_builder.rb#137
  def build_throttle_enumerator(enum, throttle_on:, backoff:); end

  # Builds Enumerator objects that iterates N times and yields number starting from zero.
  #
  # @raise [ArgumentError]
  #
  # source://job-iteration//lib/job-iteration/enumerator_builder.rb#47
  def build_times_enumerator(number, cursor:); end

  # source://job-iteration//lib/job-iteration/enumerator_builder.rb#146
  def csv(enumerable, cursor:); end

  # Builds Enumerator for nested iteration.
  #
  # @example
  #   def build_enumerator(cursor:)
  #   enumerator_builder.nested(
  #   [
  #   ->(cursor) {
  #   enumerator_builder.active_record_on_records(Shop.all, cursor: cursor)
  #   },
  #   ->(shop, cursor) {
  #   enumerator_builder.active_record_on_records(shop.products, cursor: cursor)
  #   },
  #   ->(_shop, product, cursor) {
  #   enumerator_builder.active_record_on_batch_relations(product.product_variants, cursor: cursor)
  #   }
  #   ],
  #   cursor: cursor
  #   )
  #   end
  #
  #   def each_iteration(product_variants_relation)
  #   # do something
  #   end
  # @param enums [Array<Proc>] an Array of Procs, each should return an Enumerator.
  #   Each proc from enums should accept the yielded items from the parent enumerators
  #   and the `cursor` as its arguments.
  #   Each proc's `cursor` argument is its part from the `build_enumerator`'s `cursor` array.
  # @param cursor [Array<Object>] array of offsets for each of the enums to start iteration from
  #
  # source://job-iteration//lib/job-iteration/enumerator_builder.rb#180
  def nested(enums, cursor:); end

  # Builds Enumerator objects that iterates once.
  #
  # source://job-iteration//lib/job-iteration/enumerator_builder.rb#42
  def once(cursor:); end

  # source://job-iteration//lib/job-iteration/enumerator_builder.rb#137
  def throttle(enum, throttle_on:, backoff:); end

  # Builds Enumerator objects that iterates N times and yields number starting from zero.
  #
  # @raise [ArgumentError]
  #
  # source://job-iteration//lib/job-iteration/enumerator_builder.rb#47
  def times(number, cursor:); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def wrap(*args, **_arg1, &block); end

  private

  # source://job-iteration//lib/job-iteration/enumerator_builder.rb#196
  def build_active_record_enumerator(scope, cursor:, **args); end
end

# These wrappers ensure we have a custom type that we can assert on in
# Iteration. It's useful that the `wrapper` passed to EnumeratorBuilder in
# `enumerator_builder` is _always_ the type that is returned from
# `build_enumerator`. This prevents people from implementing custom
# Enumerators without wrapping them in
# `enumerator_builder.wrap(custom_enum)`. We don't do this yet for backwards
# compatibility with raw calls to EnumeratorBuilder. Think of these wrappers
# the way you should a middleware.
#
# source://job-iteration//lib/job-iteration/enumerator_builder.rb#22
class JobIteration::EnumeratorBuilder::Wrapper < ::Enumerator
  class << self
    # source://job-iteration//lib/job-iteration/enumerator_builder.rb#24
    def wrap(_builder, enum); end
  end
end

# source://job-iteration//lib/job-iteration.rb#12
JobIteration::INTEGRATIONS = T.let(T.unsafe(nil), Array)

# source://job-iteration//lib/job-iteration.rb#10
class JobIteration::IntegrationLoadError < ::StandardError; end

# source://job-iteration//lib/job-iteration/iteration.rb#6
module JobIteration::Iteration
  extend ::ActiveSupport::Concern
  include GeneratedInstanceMethods

  mixes_in_class_methods GeneratedClassMethods
  mixes_in_class_methods ::JobIteration::Iteration::ClassMethods
  mixes_in_class_methods ::JobIteration::Iteration::PrependedClassMethods

  # source://job-iteration//lib/job-iteration/iteration.rb#101
  def initialize(*arguments, **_arg1); end

  # Returns the value of attribute cursor_position.
  #
  # source://job-iteration//lib/job-iteration/iteration.rb#9
  def cursor_position; end

  # Sets the attribute cursor_position
  #
  # @param value the value to set the attribute cursor_position to.
  #
  # source://job-iteration//lib/job-iteration/iteration.rb#9
  def cursor_position=(_arg0); end

  # @private
  #
  # source://job-iteration//lib/job-iteration/iteration.rb#119
  def deserialize(job_data); end

  # @private
  #
  # source://job-iteration//lib/job-iteration/iteration.rb#126
  def perform(*params); end

  # source://job-iteration//lib/job-iteration/iteration.rb#132
  def retry_job(*_arg0, **_arg1); end

  # @private
  #
  # source://job-iteration//lib/job-iteration/iteration.rb#111
  def serialize; end

  # The time when the job starts running. If the job is interrupted and runs again, the value is updated.
  #
  # source://job-iteration//lib/job-iteration/iteration.rb#15
  def start_time; end

  # The time when the job starts running. If the job is interrupted and runs again, the value is updated.
  #
  # source://job-iteration//lib/job-iteration/iteration.rb#15
  def start_time=(_arg0); end

  # source://job-iteration//lib/job-iteration/iteration.rb#9
  def times_interrupted; end

  # source://job-iteration//lib/job-iteration/iteration.rb#9
  def times_interrupted=(_arg0); end

  # The total time the job has been running, including multiple iterations.
  # The time isn't reset if the job is interrupted.
  #
  # source://job-iteration//lib/job-iteration/iteration.rb#19
  def total_time; end

  # The total time the job has been running, including multiple iterations.
  # The time isn't reset if the job is interrupted.
  #
  # source://job-iteration//lib/job-iteration/iteration.rb#19
  def total_time=(_arg0); end

  private

  # source://job-iteration//lib/job-iteration/iteration.rb#227
  def adjust_total_time; end

  # @raise [ArgumentError]
  #
  # source://job-iteration//lib/job-iteration/iteration.rb#231
  def assert_enumerator!(enum); end

  # source://job-iteration//lib/job-iteration/iteration.rb#258
  def assert_implements_methods!; end

  # The adapter must be able to serialize and deserialize the cursor back into an equivalent object.
  # https://github.com/mperham/sidekiq/wiki/Best-Practices#1-make-your-job-parameters-small-and-simple
  #
  # @raise [CursorError]
  #
  # source://job-iteration//lib/job-iteration/iteration.rb#248
  def assert_valid_cursor!(cursor); end

  # source://job-iteration//lib/job-iteration/iteration.rb#139
  def enumerator_builder; end

  # source://job-iteration//lib/job-iteration/iteration.rb#301
  def handle_completed(completed); end

  # source://job-iteration//lib/job-iteration/iteration.rb#289
  def instrumentation_tags; end

  # source://job-iteration//lib/job-iteration/iteration.rb#143
  def interruptible_perform(*arguments); end

  # source://job-iteration//lib/job-iteration/iteration.rb#185
  def iterate_with_enumerator(enumerator, arguments); end

  # @return [Boolean]
  #
  # source://job-iteration//lib/job-iteration/iteration.rb#293
  def job_should_exit?; end

  # source://job-iteration//lib/job-iteration/iteration.rb#278
  def method_parameters(method_name); end

  # source://job-iteration//lib/job-iteration/iteration.rb#218
  def reenqueue_iteration_job; end

  # @return [Boolean]
  #
  # source://job-iteration//lib/job-iteration/iteration.rb#334
  def serializable?(object); end

  # @return [Boolean]
  #
  # source://job-iteration//lib/job-iteration/iteration.rb#320
  def valid_cursor_parameter?(parameters); end

  module GeneratedClassMethods
    def job_iteration_max_job_runtime; end
    def job_iteration_max_job_runtime=(value); end
  end

  module GeneratedInstanceMethods
    def job_iteration_max_job_runtime; end
  end
end

# source://job-iteration//lib/job-iteration/iteration.rb#76
module JobIteration::Iteration::ClassMethods
  # source://job-iteration//lib/job-iteration/iteration.rb#77
  def method_added(method_name); end

  # source://job-iteration//lib/job-iteration/iteration.rb#90
  def on_complete(*filters, &blk); end

  # source://job-iteration//lib/job-iteration/iteration.rb#86
  def on_shutdown(*filters, &blk); end

  # source://job-iteration//lib/job-iteration/iteration.rb#82
  def on_start(*filters, &blk); end

  private

  # source://job-iteration//lib/job-iteration/iteration.rb#96
  def ban_perform_definition; end
end

# source://job-iteration//lib/job-iteration/iteration.rb#21
class JobIteration::Iteration::CursorError < ::ArgumentError
  # @return [CursorError] a new instance of CursorError
  #
  # source://job-iteration//lib/job-iteration/iteration.rb#24
  def initialize(message, cursor:); end

  # Returns the value of attribute cursor.
  #
  # source://job-iteration//lib/job-iteration/iteration.rb#22
  def cursor; end

  # source://job-iteration//lib/job-iteration/iteration.rb#29
  def message; end

  private

  # source://job-iteration//lib/job-iteration/iteration.rb#35
  def inspected_cursor; end
end

# source://job-iteration//lib/job-iteration/iteration.rb#58
module JobIteration::Iteration::PrependedClassMethods
  # source://job-iteration//lib/job-iteration/iteration.rb#59
  def job_iteration_max_job_runtime=(new); end
end

# source://job-iteration//lib/job-iteration/iteration.rb#332
JobIteration::Iteration::SIMPLE_SERIALIZABLE_CLASSES = T.let(T.unsafe(nil), Array)

# source://job-iteration//lib/job-iteration/log_subscriber.rb#4
class JobIteration::LogSubscriber < ::ActiveSupport::LogSubscriber
  # source://job-iteration//lib/job-iteration/log_subscriber.rb#29
  def completed(event); end

  # source://job-iteration//lib/job-iteration/log_subscriber.rb#22
  def interrupted(event); end

  # source://job-iteration//lib/job-iteration/log_subscriber.rb#5
  def logger; end

  # source://job-iteration//lib/job-iteration/log_subscriber.rb#9
  def nil_enumerator(event); end

  # source://job-iteration//lib/job-iteration/log_subscriber.rb#15
  def not_found(event); end
end

# @private
#
# source://job-iteration//lib/job-iteration/nested_enumerator.rb#5
class JobIteration::NestedEnumerator
  # @return [NestedEnumerator] a new instance of NestedEnumerator
  #
  # source://job-iteration//lib/job-iteration/nested_enumerator.rb#6
  def initialize(enums, cursor: T.unsafe(nil)); end

  # source://job-iteration//lib/job-iteration/nested_enumerator.rb#19
  def each(&block); end

  private

  # source://job-iteration//lib/job-iteration/nested_enumerator.rb#27
  def iterate(current_objects, index, &block); end
end

# ThrottleEnumerator allows you to throttle iterations
# based on external signal (e.g. database health).
# The enumerator from above will mimic +active_record_on_batches+,
# except when +DatabaseStatus.unhealthy?+ starts to return true.
# In that case, it will re-enqueue the job with a specified backoff.
#
# @example
#   def build_enumerator(_params, cursor:)
#   enumerator_builder.build_throttle_enumerator(
#   enumerator_builder.active_record_on_batches(
#   Account.inactive,
#   cursor: cursor
#   ),
#   throttle_on: -> { DatabaseStatus.unhealthy? },
#   backoff: 30.seconds
#   )
#   end
#
# source://job-iteration//lib/job-iteration/throttle_enumerator.rb#21
class JobIteration::ThrottleEnumerator
  # @return [ThrottleEnumerator] a new instance of ThrottleEnumerator
  #
  # source://job-iteration//lib/job-iteration/throttle_enumerator.rb#22
  def initialize(enum, job, throttle_on:, backoff:); end

  # @return [Boolean]
  #
  # source://job-iteration//lib/job-iteration/throttle_enumerator.rb#42
  def should_throttle?; end

  # source://job-iteration//lib/job-iteration/throttle_enumerator.rb#29
  def to_enum; end
end

# source://job-iteration//lib/job-iteration/version.rb#4
JobIteration::VERSION = T.let(T.unsafe(nil), String)
