# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `minitest-distributed` gem.
# Please instead update this file by running `bin/tapioca gem minitest-distributed`.

# source://minitest-distributed//lib/minitest/distributed/configuration.rb#7
module Minitest
  class << self
    # source://minitest/5.20.0/lib/minitest.rb#176
    def __run(reporter, options); end

    # source://minitest/5.20.0/lib/minitest.rb#97
    def after_run(&block); end

    # source://minitest/5.20.0/lib/minitest.rb#19
    def allow_fork; end

    # source://minitest/5.20.0/lib/minitest.rb#19
    def allow_fork=(_arg0); end

    # source://minitest/5.20.0/lib/minitest.rb#69
    def autorun; end

    # source://minitest/5.20.0/lib/minitest.rb#19
    def backtrace_filter; end

    # source://minitest/5.20.0/lib/minitest.rb#19
    def backtrace_filter=(_arg0); end

    # source://minitest/5.20.0/lib/minitest.rb#18
    def cattr_accessor(name); end

    # source://minitest/5.20.0/lib/minitest.rb#1102
    def clock_time; end

    # source://minitest/5.20.0/lib/minitest.rb#19
    def extensions; end

    # source://minitest/5.20.0/lib/minitest.rb#19
    def extensions=(_arg0); end

    # source://minitest/5.20.0/lib/minitest.rb#267
    def filter_backtrace(bt); end

    # source://minitest/5.20.0/lib/minitest.rb#19
    def info_signal; end

    # source://minitest/5.20.0/lib/minitest.rb#19
    def info_signal=(_arg0); end

    # source://minitest/5.20.0/lib/minitest.rb#101
    def init_plugins(options); end

    # source://minitest/5.20.0/lib/minitest.rb#108
    def load_plugins; end

    # source://minitest/5.20.0/lib/minitest.rb#19
    def parallel_executor; end

    # source://minitest/5.20.0/lib/minitest.rb#19
    def parallel_executor=(_arg0); end

    # source://minitest/5.20.0/lib/minitest.rb#189
    def process_args(args = T.unsafe(nil)); end

    # source://minitest/5.20.0/lib/minitest.rb#19
    def reporter; end

    # source://minitest/5.20.0/lib/minitest.rb#19
    def reporter=(_arg0); end

    # source://minitest/5.20.0/lib/minitest.rb#143
    def run(args = T.unsafe(nil)); end

    # source://minitest/5.20.0/lib/minitest.rb#1093
    def run_one_method(klass, method_name); end

    # source://minitest/5.20.0/lib/minitest.rb#19
    def seed; end

    # source://minitest/5.20.0/lib/minitest.rb#19
    def seed=(_arg0); end
  end
end

# source://minitest-distributed//lib/minitest/distributed/result_type.rb#72
class Minitest::AttemptsExhausted < ::Minitest::Assertion; end

# source://minitest-distributed//lib/minitest/distributed/result_type.rb#5
class Minitest::Discard < ::Minitest::Skip
  # source://minitest-distributed//lib/minitest/distributed/result_type.rb#12
  sig { params(message: ::String, original_result: ::Minitest::Result).void }
  def initialize(message, original_result:); end

  # source://minitest-distributed//lib/minitest/distributed/result_type.rb#9
  sig { returns(::Minitest::Result) }
  def original_result; end

  # source://minitest-distributed//lib/minitest/distributed/result_type.rb#18
  sig { override.returns(::String) }
  def result_label; end

  class << self
    # source://minitest-distributed//lib/minitest/distributed/result_type.rb#23
    sig { params(result: ::Minitest::Result, test_timeout_seconds: ::Float).returns(::Minitest::Result) }
    def wrap(result, test_timeout_seconds:); end
  end
end

# source://minitest-distributed//lib/minitest/distributed/configuration.rb#8
module Minitest::Distributed; end

# source://minitest-distributed//lib/minitest/distributed/configuration.rb#9
class Minitest::Distributed::Configuration < ::T::Struct
  prop :coordinator_uri, ::URI::Generic, default: T.unsafe(nil)
  prop :run_id, ::String, default: T.unsafe(nil)
  prop :worker_id, ::String, default: T.unsafe(nil)
  prop :test_timeout_seconds, ::Float, default: T.unsafe(nil)
  prop :test_batch_size, ::Integer, default: T.unsafe(nil)
  prop :max_attempts, ::Integer, default: T.unsafe(nil)
  prop :max_failures, T.nilable(::Integer)
  prop :retry_failures, T::Boolean, default: T.unsafe(nil)
  prop :progress, T::Boolean, default: T.unsafe(nil)
  prop :exclude_file, T.nilable(::String)
  prop :include_file, T.nilable(::String)
  prop :shuffle_suites, T::Boolean, default: T.unsafe(nil)

  # source://minitest-distributed//lib/minitest/distributed/configuration.rb#107
  sig { returns(::Minitest::Distributed::Coordinators::CoordinatorInterface) }
  def coordinator; end

  class << self
    # source://minitest-distributed//lib/minitest/distributed/configuration.rb#31
    sig { params(opts: ::OptionParser, options: T::Hash[::Symbol, T.untyped]).returns(T.attached_class) }
    def from_command_line_options(opts, options); end

    # source://minitest-distributed//lib/minitest/distributed/configuration.rb#18
    sig { params(env: T::Hash[::String, T.nilable(::String)]).returns(T.attached_class) }
    def from_env(env = T.unsafe(nil)); end

    # source://sorbet-runtime/0.5.11146/lib/types/struct.rb#13
    def inherited(s); end
  end
end

# source://minitest-distributed//lib/minitest/distributed/configuration.rb#10
Minitest::Distributed::Configuration::DEFAULT_BATCH_SIZE = T.let(T.unsafe(nil), Integer)

# source://minitest-distributed//lib/minitest/distributed/configuration.rb#11
Minitest::Distributed::Configuration::DEFAULT_MAX_ATTEMPTS = T.let(T.unsafe(nil), Integer)

# seconds
#
# source://minitest-distributed//lib/minitest/distributed/configuration.rb#12
Minitest::Distributed::Configuration::DEFAULT_TEST_TIMEOUT_SECONDS = T.let(T.unsafe(nil), Float)

# source://minitest-distributed//lib/minitest/distributed/coordinators/coordinator_interface.rb#6
module Minitest::Distributed::Coordinators; end

# @abstract Subclasses must implement the `abstract` methods below.
#
# source://minitest-distributed//lib/minitest/distributed/coordinators/coordinator_interface.rb#7
module Minitest::Distributed::Coordinators::CoordinatorInterface
  interface!

  # @abstract
  #
  # source://minitest-distributed//lib/minitest/distributed/coordinators/coordinator_interface.rb#22
  sig { abstract.returns(T::Boolean) }
  def aborted?; end

  # @abstract
  #
  # source://minitest-distributed//lib/minitest/distributed/coordinators/coordinator_interface.rb#19
  sig { abstract.returns(::Minitest::Distributed::ResultAggregate) }
  def combined_results; end

  # @abstract
  #
  # source://minitest-distributed//lib/minitest/distributed/coordinators/coordinator_interface.rb#28
  sig { abstract.params(reporter: ::Minitest::AbstractReporter).void }
  def consume(reporter:); end

  # @abstract
  #
  # source://minitest-distributed//lib/minitest/distributed/coordinators/coordinator_interface.rb#16
  sig { abstract.returns(::Minitest::Distributed::ResultAggregate) }
  def local_results; end

  # @abstract
  #
  # source://minitest-distributed//lib/minitest/distributed/coordinators/coordinator_interface.rb#25
  sig { abstract.params(test_selector: ::Minitest::Distributed::TestSelector).void }
  def produce(test_selector:); end

  # @abstract
  #
  # source://minitest-distributed//lib/minitest/distributed/coordinators/coordinator_interface.rb#13
  sig { abstract.params(reporter: ::Minitest::CompositeReporter, options: T::Hash[::Symbol, T.untyped]).void }
  def register_reporters(reporter:, options:); end
end

# source://minitest-distributed//lib/minitest/distributed/coordinators/memory_coordinator.rb#7
class Minitest::Distributed::Coordinators::MemoryCoordinator
  include ::Minitest::Distributed::Coordinators::CoordinatorInterface

  # source://minitest-distributed//lib/minitest/distributed/coordinators/memory_coordinator.rb#23
  sig { params(configuration: ::Minitest::Distributed::Configuration).void }
  def initialize(configuration:); end

  # source://minitest-distributed//lib/minitest/distributed/coordinators/memory_coordinator.rb#38
  sig { override.returns(T::Boolean) }
  def aborted?; end

  # @return [ResultAggregate]
  #
  # source://sorbet-runtime/0.5.11146/lib/types/private/methods/_methods.rb#255
  def combined_results(*args, **_arg1, &blk); end

  # source://minitest-distributed//lib/minitest/distributed/coordinators/memory_coordinator.rb#12
  sig { returns(::Minitest::Distributed::Configuration) }
  def configuration; end

  # source://minitest-distributed//lib/minitest/distributed/coordinators/memory_coordinator.rb#63
  sig { override.params(reporter: ::Minitest::AbstractReporter).void }
  def consume(reporter:); end

  # source://minitest-distributed//lib/minitest/distributed/coordinators/memory_coordinator.rb#18
  sig { override.returns(::Minitest::Distributed::ResultAggregate) }
  def local_results; end

  # source://minitest-distributed//lib/minitest/distributed/coordinators/memory_coordinator.rb#43
  sig { override.params(test_selector: ::Minitest::Distributed::TestSelector).void }
  def produce(test_selector:); end

  # source://minitest-distributed//lib/minitest/distributed/coordinators/memory_coordinator.rb#15
  sig { returns(::Thread::Queue) }
  def queue; end

  # source://minitest-distributed//lib/minitest/distributed/coordinators/memory_coordinator.rb#33
  sig { override.params(reporter: ::Minitest::CompositeReporter, options: T::Hash[::Symbol, T.untyped]).void }
  def register_reporters(reporter:, options:); end
end

# The RedisCoordinator is an implementation of the test coordinator interface
# using a Redis stream + consumergroup for coordination.
#
# We assume a bunch of workers will be started at the same time. Every worker
# will try to become the leader by trying to create the consumergroup. Only one
# will succeed, which will then continue to populate the list of tests to run
# to the stream.
#
# AFter that, all workers will start consuming from the stream. They will first
# try to claim stale entries from other workers (determined by the `test_timeout_seconds`
# option), and process them up to a maximum of `max_attempts` attempts. Then,
# they will consume tests from the stream, run them, and ack them. This is done
# in batches to reduce load on Redis.
#
# Retrying failed tests (up to `max_attempts` times) uses the same mechanism.
# When a test fails, and we haven't exhausted the maximum number of attempts, we
# do not ACK the result with Redis. The means that another worker will eventually
# claim the test, and run it again. However, in this case we don't want to slow
# things down unnecessarily. When a test fails and we want to retry it, we add the
# test to the `retry_set` in Redis. When other worker sees that a test is in this
# set, it can immediately claim the test, rather than waiting for the timeout.
#
# Finally, when we have acked the same number of tests as we populated into the
# queue, the run is considered finished. The first worker to detect this will
# remove the consumergroup and the associated stream from Redis.
#
# If a worker starts for the same run_id while it is already considered completed,
# it will start a "retry run". It will find all the tests that failed/errored on
# the previous attempt, and schedule only those tests to be run, rather than the
# full test suite returned by the test selector. This can be useful to retry flaky
# tests. Subsequent workers coming online will join this worker to form a consumer
# group exactly as described above.
#
# source://minitest-distributed//lib/minitest/distributed/coordinators/redis_coordinator.rb#42
class Minitest::Distributed::Coordinators::RedisCoordinator
  include ::Minitest::Distributed::Coordinators::CoordinatorInterface

  # source://minitest-distributed//lib/minitest/distributed/coordinators/redis_coordinator.rb#65
  sig { params(configuration: ::Minitest::Distributed::Configuration).void }
  def initialize(configuration:); end

  # source://minitest-distributed//lib/minitest/distributed/coordinators/redis_coordinator.rb#121
  sig { override.returns(T::Boolean) }
  def aborted?; end

  # source://minitest-distributed//lib/minitest/distributed/coordinators/redis_coordinator.rb#84
  sig { override.returns(::Minitest::Distributed::ResultAggregate) }
  def combined_results; end

  # source://minitest-distributed//lib/minitest/distributed/coordinators/redis_coordinator.rb#47
  sig { returns(::Minitest::Distributed::Configuration) }
  def configuration; end

  # source://minitest-distributed//lib/minitest/distributed/coordinators/redis_coordinator.rb#221
  sig { override.params(reporter: ::Minitest::AbstractReporter).void }
  def consume(reporter:); end

  # source://minitest-distributed//lib/minitest/distributed/coordinators/redis_coordinator.rb#53
  sig { returns(::String) }
  def group_name; end

  # source://minitest-distributed//lib/minitest/distributed/coordinators/redis_coordinator.rb#56
  sig { override.returns(::Minitest::Distributed::ResultAggregate) }
  def local_results; end

  # source://minitest-distributed//lib/minitest/distributed/coordinators/redis_coordinator.rb#126
  sig { override.params(test_selector: ::Minitest::Distributed::TestSelector).void }
  def produce(test_selector:); end

  # source://minitest-distributed//lib/minitest/distributed/coordinators/redis_coordinator.rb#62
  sig { returns(T::Set[::Minitest::Distributed::EnqueuedRunnable]) }
  def reclaimed_failed_tests; end

  # source://minitest-distributed//lib/minitest/distributed/coordinators/redis_coordinator.rb#59
  sig { returns(T::Set[::Minitest::Distributed::EnqueuedRunnable]) }
  def reclaimed_timeout_tests; end

  # source://minitest-distributed//lib/minitest/distributed/coordinators/redis_coordinator.rb#79
  sig { override.params(reporter: ::Minitest::CompositeReporter, options: T::Hash[::Symbol, T.untyped]).void }
  def register_reporters(reporter:, options:); end

  # source://minitest-distributed//lib/minitest/distributed/coordinators/redis_coordinator.rb#50
  sig { returns(::String) }
  def stream_key; end

  private

  # source://minitest-distributed//lib/minitest/distributed/coordinators/redis_coordinator.rb#432
  sig { params(results: ::Minitest::Distributed::ResultAggregate).void }
  def adjust_combined_results(results); end

  # source://minitest-distributed//lib/minitest/distributed/coordinators/redis_coordinator.rb#292
  sig { params(block: ::Integer).returns(T::Array[::Minitest::Distributed::EnqueuedRunnable]) }
  def claim_fresh_runnables(block:); end

  # source://minitest-distributed//lib/minitest/distributed/coordinators/redis_coordinator.rb#325
  sig { returns(T::Array[::Minitest::Distributed::EnqueuedRunnable]) }
  def claim_stale_runnables; end

  # source://minitest-distributed//lib/minitest/distributed/coordinators/redis_coordinator.rb#423
  sig { void }
  def cleanup; end

  # source://minitest-distributed//lib/minitest/distributed/coordinators/redis_coordinator.rb#462
  sig { params(name: ::String).returns(::String) }
  def key(name); end

  # source://minitest-distributed//lib/minitest/distributed/coordinators/redis_coordinator.rb#467
  sig { params(name: ::String).returns(::String) }
  def list_key(name); end

  # source://minitest-distributed//lib/minitest/distributed/coordinators/redis_coordinator.rb#472
  sig do
    params(
      batch: T::Array[::Minitest::Distributed::EnqueuedRunnable],
      reporter: ::Minitest::AbstractReporter
    ).void
  end
  def process_batch(batch, reporter); end

  # source://minitest-distributed//lib/minitest/distributed/coordinators/redis_coordinator.rb#270
  sig { returns(::Redis) }
  def redis; end

  # source://minitest-distributed//lib/minitest/distributed/coordinators/redis_coordinator.rb#275
  sig { returns(::String) }
  def register_consumergroup_script; end

  # source://minitest-distributed//lib/minitest/distributed/coordinators/redis_coordinator.rb#310
  sig do
    params(
      pending_messages: T::Hash[::String, ::Minitest::Distributed::PendingExecution],
      max_idle_time_ms: ::Integer
    ).returns(T::Array[::Minitest::Distributed::EnqueuedRunnable])
  end
  def xclaim_messages(pending_messages, max_idle_time_ms:); end
end

# milliseconds
#
# source://minitest-distributed//lib/minitest/distributed/coordinators/redis_coordinator.rb#521
Minitest::Distributed::Coordinators::RedisCoordinator::INITIAL_BACKOFF = T.let(T.unsafe(nil), Integer)

# This module defines some helper methods to deal with Minitest::Runnable
#
# source://minitest-distributed//lib/minitest/distributed/enqueued_runnable.rb#31
module Minitest::Distributed::DefinedRunnable
  class << self
    # source://minitest-distributed//lib/minitest/distributed/enqueued_runnable.rb#35
    sig { params(name: ::String).returns(T.class_of(Minitest::Runnable)) }
    def find_class(name); end

    # source://minitest-distributed//lib/minitest/distributed/enqueued_runnable.rb#46
    sig { params(identifier: ::String).returns(::Minitest::Runnable) }
    def from_identifier(identifier); end

    # source://minitest-distributed//lib/minitest/distributed/enqueued_runnable.rb#41
    sig { params(runnable: ::Minitest::Runnable).returns(::String) }
    def identifier(runnable); end
  end
end

# source://minitest-distributed//lib/minitest/distributed/enqueued_runnable.rb#52
class Minitest::Distributed::EnqueuedRunnable < ::T::Struct
  const :class_name, ::String
  const :method_name, ::String
  const :entry_id, ::String, default: T.unsafe(nil)
  const :attempt, ::Integer, default: T.unsafe(nil)
  const :max_attempts, ::Integer
  const :test_timeout_seconds, ::Float

  # source://minitest-distributed//lib/minitest/distributed/enqueued_runnable.rb#162
  sig { returns(::String) }
  def attempt_id; end

  # source://minitest-distributed//lib/minitest/distributed/enqueued_runnable.rb#177
  sig { returns(T::Boolean) }
  def attempts_exhausted?; end

  # source://minitest-distributed//lib/minitest/distributed/enqueued_runnable.rb#187
  sig { returns(::Minitest::Result) }
  def attempts_exhausted_result; end

  # source://minitest-distributed//lib/minitest/distributed/enqueued_runnable.rb#209
  sig do
    params(
      initial_result: ::Minitest::Result,
      block: T.proc.params(arg0: ::Minitest::Result).returns(::Minitest::Distributed::EnqueuedRunnable::Result::Commit)
    ).returns(::Minitest::Distributed::EnqueuedRunnable::Result)
  end
  def commit_result(initial_result, &block); end

  # source://minitest-distributed//lib/minitest/distributed/enqueued_runnable.rb#182
  sig { returns(T::Boolean) }
  def final_attempt?; end

  # source://minitest-distributed//lib/minitest/distributed/enqueued_runnable.rb#157
  sig { returns(::String) }
  def identifier; end

  # source://minitest-distributed//lib/minitest/distributed/enqueued_runnable.rb#172
  sig { returns(::Minitest::Runnable) }
  def instantiate_runnable; end

  # source://minitest-distributed//lib/minitest/distributed/enqueued_runnable.rb#233
  sig { returns(T.self_type) }
  def next_attempt; end

  # source://minitest-distributed//lib/minitest/distributed/enqueued_runnable.rb#218
  sig { returns(::Minitest::Result) }
  def run; end

  # source://minitest-distributed//lib/minitest/distributed/enqueued_runnable.rb#167
  sig { returns(T.class_of(Minitest::Runnable)) }
  def runnable_class; end

  class << self
    # source://minitest-distributed//lib/minitest/distributed/enqueued_runnable.rb#129
    sig do
      params(
        claims: T::Array[[::String, T::Hash[::String, ::String]]],
        pending_messages: T::Hash[::String, ::Minitest::Distributed::PendingExecution],
        configuration: ::Minitest::Distributed::Configuration
      ).returns(T::Array[T.attached_class])
    end
    def from_redis_stream_claim(claims, pending_messages = T.unsafe(nil), configuration:); end

    # source://sorbet-runtime/0.5.11146/lib/types/struct.rb#13
    def inherited(s); end
  end
end

# source://minitest-distributed//lib/minitest/distributed/enqueued_runnable.rb#53
class Minitest::Distributed::EnqueuedRunnable::Result < ::T::Struct
  const :enqueued_runnable, ::Minitest::Distributed::EnqueuedRunnable
  const :initial_result, ::Minitest::Result
  const :commit, ::Minitest::Distributed::EnqueuedRunnable::Result::Commit

  # source://minitest-distributed//lib/minitest/distributed/enqueued_runnable.rb#108
  sig { returns(::Minitest::Result) }
  def committed_result; end

  # source://minitest-distributed//lib/minitest/distributed/enqueued_runnable.rb#93
  sig { returns(::String) }
  def entry_id; end

  # source://minitest-distributed//lib/minitest/distributed/enqueued_runnable.rb#98
  sig { returns(T::Boolean) }
  def final?; end

  # source://minitest-distributed//lib/minitest/distributed/enqueued_runnable.rb#103
  sig { returns(T::Boolean) }
  def requeue?; end

  class << self
    # source://sorbet-runtime/0.5.11146/lib/types/struct.rb#13
    def inherited(s); end
  end
end

# source://minitest-distributed//lib/minitest/distributed/enqueued_runnable.rb#54
class Minitest::Distributed::EnqueuedRunnable::Result::Commit
  # source://minitest-distributed//lib/minitest/distributed/enqueued_runnable.rb#58
  sig { params(block: T.proc.returns(T::Boolean)).void }
  def initialize(&block); end

  # source://minitest-distributed//lib/minitest/distributed/enqueued_runnable.rb#69
  sig { returns(T::Boolean) }
  def failure?; end

  # source://minitest-distributed//lib/minitest/distributed/enqueued_runnable.rb#63
  sig { returns(T::Boolean) }
  def success?; end

  class << self
    # source://minitest-distributed//lib/minitest/distributed/enqueued_runnable.rb#80
    sig { returns(::Minitest::Distributed::EnqueuedRunnable::Result::Commit) }
    def failure; end

    # source://minitest-distributed//lib/minitest/distributed/enqueued_runnable.rb#74
    sig { returns(::Minitest::Distributed::EnqueuedRunnable::Result::Commit) }
    def success; end
  end
end

# source://minitest-distributed//lib/minitest/distributed.rb#28
class Minitest::Distributed::Error < ::StandardError; end

# source://minitest-distributed//lib/minitest/distributed/filters/filter_interface.rb#6
module Minitest::Distributed::Filters; end

# source://minitest-distributed//lib/minitest/distributed/filters/exclude_file_filter.rb#7
class Minitest::Distributed::Filters::ExcludeFileFilter < ::Minitest::Distributed::Filters::FileFilterBase
  include ::Minitest::Distributed::Filters::FilterInterface

  # source://minitest-distributed//lib/minitest/distributed/filters/exclude_file_filter.rb#12
  sig { override.params(runnable: ::Minitest::Runnable).returns(T::Array[::Minitest::Runnable]) }
  def call(runnable); end
end

# source://minitest-distributed//lib/minitest/distributed/filters/exclude_filter.rb#7
class Minitest::Distributed::Filters::ExcludeFilter
  include ::Minitest::Distributed::Filters::FilterInterface

  # source://minitest-distributed//lib/minitest/distributed/filters/exclude_filter.rb#15
  sig { params(filter: T.any(::Regexp, ::String)).void }
  def initialize(filter); end

  # source://minitest-distributed//lib/minitest/distributed/filters/exclude_filter.rb#23
  sig { override.params(runnable: ::Minitest::Runnable).returns(T::Array[::Minitest::Runnable]) }
  def call(runnable); end

  # source://minitest-distributed//lib/minitest/distributed/filters/exclude_filter.rb#12
  sig { returns(T.any(::Regexp, ::String)) }
  def filter; end
end

# source://minitest-distributed//lib/minitest/distributed/filters/file_filter_base.rb#7
class Minitest::Distributed::Filters::FileFilterBase
  # source://minitest-distributed//lib/minitest/distributed/filters/file_filter_base.rb#14
  sig { params(file: ::Pathname).void }
  def initialize(file); end

  # source://minitest-distributed//lib/minitest/distributed/filters/file_filter_base.rb#11
  sig { returns(::Pathname) }
  def file; end

  # source://minitest-distributed//lib/minitest/distributed/filters/file_filter_base.rb#20
  sig { returns(T::Set[::String]) }
  def tests; end
end

# A filter proc is a callable object that changes the list of runnables that will
# be executed during the test run. For every runnable, it should return an
# array of runnables.
#
# - If it returns an empty array, the runnable will not be run.
# - If it returns a single element array with the passed ion runnable to make no changes.
# - It can return an array of enumerables to expand the number of runnables in this test run,
#   We use this for grinding tests, for instance.
#
# @abstract Subclasses must implement the `abstract` methods below.
#
# source://minitest-distributed//lib/minitest/distributed/filters/filter_interface.rb#15
module Minitest::Distributed::Filters::FilterInterface
  interface!

  # @abstract
  #
  # source://minitest-distributed//lib/minitest/distributed/filters/filter_interface.rb#21
  sig { abstract.params(runnable: ::Minitest::Runnable).returns(T::Array[::Minitest::Runnable]) }
  def call(runnable); end
end

# source://minitest-distributed//lib/minitest/distributed/filters/include_file_filter.rb#7
class Minitest::Distributed::Filters::IncludeFileFilter < ::Minitest::Distributed::Filters::FileFilterBase
  include ::Minitest::Distributed::Filters::FilterInterface

  # source://minitest-distributed//lib/minitest/distributed/filters/include_file_filter.rb#12
  sig { override.params(runnable: ::Minitest::Runnable).returns(T::Array[::Minitest::Runnable]) }
  def call(runnable); end
end

# source://minitest-distributed//lib/minitest/distributed/filters/include_filter.rb#7
class Minitest::Distributed::Filters::IncludeFilter
  include ::Minitest::Distributed::Filters::FilterInterface

  # source://minitest-distributed//lib/minitest/distributed/filters/include_filter.rb#15
  sig { params(filter: T.any(::Regexp, ::String)).void }
  def initialize(filter); end

  # source://minitest-distributed//lib/minitest/distributed/filters/include_filter.rb#23
  sig { override.params(runnable: ::Minitest::Runnable).returns(T::Array[::Minitest::Runnable]) }
  def call(runnable); end

  # source://minitest-distributed//lib/minitest/distributed/filters/include_filter.rb#12
  sig { returns(T.any(::Regexp, ::String)) }
  def filter; end
end

# source://minitest-distributed//lib/minitest/distributed/enqueued_runnable.rb#6
class Minitest::Distributed::PendingExecution < ::T::Struct
  const :worker_id, ::String
  const :entry_id, ::String
  const :elapsed_time_ms, ::Integer
  const :attempt, ::Integer

  # source://minitest-distributed//lib/minitest/distributed/enqueued_runnable.rb#15
  sig { returns(::String) }
  def attempt_id; end

  class << self
    # source://minitest-distributed//lib/minitest/distributed/enqueued_runnable.rb#20
    sig { params(xpending_result: T::Hash[::String, T.untyped]).returns(T.attached_class) }
    def from_xpending(xpending_result); end

    # source://sorbet-runtime/0.5.11146/lib/types/struct.rb#13
    def inherited(s); end
  end
end

# source://minitest-distributed//lib/minitest/distributed/reporters/redis_coordinator_warnings_reporter.rb#6
module Minitest::Distributed::Reporters; end

# source://minitest-distributed//lib/minitest/distributed/reporters/distributed_progress_reporter.rb#9
class Minitest::Distributed::Reporters::DistributedPogressReporter < ::Minitest::Reporter
  # source://minitest-distributed//lib/minitest/distributed/reporters/distributed_progress_reporter.rb#16
  sig { params(io: ::IO, options: T::Hash[::Symbol, T.untyped]).void }
  def initialize(io, options); end

  # source://minitest-distributed//lib/minitest/distributed/reporters/distributed_progress_reporter.rb#13
  sig { returns(::Minitest::Distributed::Coordinators::CoordinatorInterface) }
  def coordinator; end

  # NOTE: due to batching and parallel tests, we have no guarantee that `prerecord`
  # and `record` will be called in succession for the same test without calls to
  # either method being interjected for other tests.
  #
  # As a result we have no idea what will be on the last line of the console.
  # We always clear the full line before printing output.
  #
  # source://minitest-distributed//lib/minitest/distributed/reporters/distributed_progress_reporter.rb#40
  sig { override.params(klass: T.class_of(Minitest::Runnable), name: ::String).void }
  def prerecord(klass, name); end

  # source://minitest-distributed//lib/minitest/distributed/reporters/distributed_progress_reporter.rb#48
  sig { override.params(result: ::Minitest::Result).void }
  def record(result); end

  # source://minitest-distributed//lib/minitest/distributed/reporters/distributed_progress_reporter.rb#64
  sig { override.void }
  def report; end

  # source://minitest-distributed//lib/minitest/distributed/reporters/distributed_progress_reporter.rb#27
  sig { override.void }
  def start; end

  private

  # source://minitest-distributed//lib/minitest/distributed/reporters/distributed_progress_reporter.rb#76
  sig { void }
  def clear_current_line; end

  # source://minitest-distributed//lib/minitest/distributed/reporters/distributed_progress_reporter.rb#91
  sig { returns(::Minitest::Distributed::ResultAggregate) }
  def results; end

  # source://minitest-distributed//lib/minitest/distributed/reporters/distributed_progress_reporter.rb#71
  sig { returns(T::Boolean) }
  def show_progress?; end

  # source://minitest-distributed//lib/minitest/distributed/reporters/distributed_progress_reporter.rb#81
  sig { returns(::Integer) }
  def window_line_width; end
end

# source://minitest-distributed//lib/minitest/distributed/reporters/distributed_summary_reporter.rb#7
class Minitest::Distributed::Reporters::DistributedSummaryReporter < ::Minitest::Reporter
  # source://minitest-distributed//lib/minitest/distributed/reporters/distributed_summary_reporter.rb#11
  sig { params(io: ::IO, options: T::Hash[::Symbol, T.untyped]).void }
  def initialize(io, options); end

  # source://minitest-distributed//lib/minitest/distributed/reporters/distributed_summary_reporter.rb#45
  sig { override.returns(T::Boolean) }
  def passed?; end

  # source://minitest-distributed//lib/minitest/distributed/reporters/distributed_summary_reporter.rb#24
  sig { override.void }
  def report; end

  # source://minitest-distributed//lib/minitest/distributed/reporters/distributed_summary_reporter.rb#18
  sig { override.void }
  def start; end

  protected

  # source://minitest-distributed//lib/minitest/distributed/reporters/distributed_summary_reporter.rb#75
  sig { returns(::Minitest::Distributed::ResultAggregate) }
  def combined_results; end

  # source://minitest-distributed//lib/minitest/distributed/reporters/distributed_summary_reporter.rb#81
  sig { returns(::Minitest::Distributed::Configuration) }
  def configuration; end

  # source://minitest-distributed//lib/minitest/distributed/reporters/distributed_summary_reporter.rb#69
  sig { returns(::Minitest::Distributed::ResultAggregate) }
  def local_results; end

  # source://minitest-distributed//lib/minitest/distributed/reporters/distributed_summary_reporter.rb#59
  sig { void }
  def print_discard_warning; end
end

# source://minitest-distributed//lib/minitest/distributed/reporters/redis_coordinator_warnings_reporter.rb#7
class Minitest::Distributed::Reporters::RedisCoordinatorWarningsReporter < ::Minitest::Reporter
  # source://minitest-distributed//lib/minitest/distributed/reporters/redis_coordinator_warnings_reporter.rb#11
  sig { override.void }
  def report; end

  private

  # source://minitest-distributed//lib/minitest/distributed/reporters/redis_coordinator_warnings_reporter.rb#22
  sig { returns(::Minitest::Distributed::Configuration) }
  def configuration; end

  # source://minitest-distributed//lib/minitest/distributed/reporters/redis_coordinator_warnings_reporter.rb#45
  sig { returns(T.nilable(::String)) }
  def reclaim_failed_warning; end

  # source://minitest-distributed//lib/minitest/distributed/reporters/redis_coordinator_warnings_reporter.rb#32
  sig { returns(T.nilable(::String)) }
  def reclaim_timeout_warning; end

  # source://minitest-distributed//lib/minitest/distributed/reporters/redis_coordinator_warnings_reporter.rb#27
  sig { returns(::Minitest::Distributed::Coordinators::RedisCoordinator) }
  def redis_coordinator; end
end

# source://minitest-distributed//lib/minitest/distributed/result_aggregate.rb#6
class Minitest::Distributed::ResultAggregate < ::T::Struct
  const :max_failures, T.nilable(::Integer)
  prop :runs, ::Integer, default: T.unsafe(nil)
  prop :assertions, ::Integer, default: T.unsafe(nil)
  prop :passes, ::Integer, default: T.unsafe(nil)
  prop :failures, ::Integer, default: T.unsafe(nil)
  prop :errors, ::Integer, default: T.unsafe(nil)
  prop :skips, ::Integer, default: T.unsafe(nil)
  prop :requeues, ::Integer, default: T.unsafe(nil)
  prop :discards, ::Integer, default: T.unsafe(nil)
  prop :acks, ::Integer, default: T.unsafe(nil)
  prop :size, ::Integer, default: T.unsafe(nil)

  # source://minitest-distributed//lib/minitest/distributed/result_aggregate.rb#67
  sig { returns(T::Boolean) }
  def abort?; end

  # source://minitest-distributed//lib/minitest/distributed/result_aggregate.rb#81
  sig { returns(T::Boolean) }
  def all_runs_reported?; end

  # source://minitest-distributed//lib/minitest/distributed/result_aggregate.rb#62
  sig { returns(T::Boolean) }
  def complete?; end

  # source://minitest-distributed//lib/minitest/distributed/result_aggregate.rb#91
  sig { returns(T::Boolean) }
  def passed?; end

  # source://minitest-distributed//lib/minitest/distributed/result_aggregate.rb#57
  sig { returns(::Integer) }
  def reported_results; end

  # source://minitest-distributed//lib/minitest/distributed/result_aggregate.rb#43
  sig { returns(::String) }
  def to_s; end

  # source://minitest-distributed//lib/minitest/distributed/result_aggregate.rb#86
  sig { returns(::Integer) }
  def total_failures; end

  # source://minitest-distributed//lib/minitest/distributed/result_aggregate.rb#52
  sig { returns(::Integer) }
  def unique_runs; end

  # source://minitest-distributed//lib/minitest/distributed/result_aggregate.rb#26
  sig { params(runnable_result: ::Minitest::Distributed::EnqueuedRunnable::Result).void }
  def update_with_result(runnable_result); end

  # source://minitest-distributed//lib/minitest/distributed/result_aggregate.rb#76
  sig { returns(T::Boolean) }
  def valid?; end

  class << self
    # source://sorbet-runtime/0.5.11146/lib/types/struct.rb#13
    def inherited(s); end
  end
end

# source://minitest-distributed//lib/minitest/distributed/result_type.rb#76
class Minitest::Distributed::ResultType < ::T::Enum
  enums do
    Passed = new
    Failed = new
    Error = new
    Skipped = new
    Discarded = new
    Requeued = new
  end

  class << self
    # source://minitest-distributed//lib/minitest/distributed/result_type.rb#89
    sig { params(result: ::Minitest::Result).returns(::Minitest::Distributed::ResultType) }
    def of(result); end
  end
end

# source://minitest-distributed//lib/minitest/distributed/test_runner.rb#6
class Minitest::Distributed::TestRunner
  # source://minitest-distributed//lib/minitest/distributed/test_runner.rb#22
  sig { params(options: T::Hash[::Symbol, T.untyped]).void }
  def initialize(options); end

  # source://minitest-distributed//lib/minitest/distributed/test_runner.rb#13
  sig { returns(::Minitest::Distributed::Configuration) }
  def configuration; end

  # source://minitest-distributed//lib/minitest/distributed/test_runner.rb#19
  sig { returns(::Minitest::Distributed::Coordinators::CoordinatorInterface) }
  def coordinator; end

  # source://minitest-distributed//lib/minitest/distributed/test_runner.rb#10
  sig { returns(T::Hash[::Symbol, T.untyped]) }
  def options; end

  # source://minitest-distributed//lib/minitest/distributed/test_runner.rb#31
  sig { params(reporter: ::Minitest::AbstractReporter).void }
  def run(reporter); end

  # source://minitest-distributed//lib/minitest/distributed/test_runner.rb#16
  sig { returns(::Minitest::Distributed::TestSelector) }
  def test_selector; end
end

# source://minitest-distributed//lib/minitest/distributed.rb#30
module Minitest::Distributed::TestRunnerPatch
  # source://minitest-distributed//lib/minitest/distributed.rb#34
  sig { params(reporter: ::Minitest::AbstractReporter, options: T::Hash[::Symbol, T.untyped]).void }
  def __run(reporter, options); end
end

# source://minitest-distributed//lib/minitest/distributed/test_selector.rb#8
class Minitest::Distributed::TestSelector
  # source://minitest-distributed//lib/minitest/distributed/test_selector.rb#18
  sig { params(options: T::Hash[::Symbol, T.untyped]).void }
  def initialize(options); end

  # source://minitest-distributed//lib/minitest/distributed/test_selector.rb#38
  sig { returns(T::Array[::Minitest::Runnable]) }
  def discover_tests; end

  # source://minitest-distributed//lib/minitest/distributed/test_selector.rb#15
  sig { returns(T::Array[::Minitest::Distributed::Filters::FilterInterface]) }
  def filters; end

  # source://minitest-distributed//lib/minitest/distributed/test_selector.rb#26
  sig { void }
  def initialize_filters; end

  # source://minitest-distributed//lib/minitest/distributed/test_selector.rb#12
  sig { returns(T::Hash[::Symbol, T.untyped]) }
  def options; end

  # source://minitest-distributed//lib/minitest/distributed/test_selector.rb#45
  sig { returns(T::Array[T.class_of(Minitest::Runnable)]) }
  def runnables; end

  # source://minitest-distributed//lib/minitest/distributed/test_selector.rb#55
  sig { params(tests: T::Array[::Minitest::Runnable]).returns(T::Array[::Minitest::Runnable]) }
  def select_tests(tests); end

  # source://minitest-distributed//lib/minitest/distributed/test_selector.rb#66
  sig { returns(T::Array[::Minitest::Runnable]) }
  def tests; end
end

# source://minitest-distributed//lib/minitest/distributed/result_type.rb#44
class Minitest::Requeue < ::Minitest::Skip
  # source://minitest-distributed//lib/minitest/distributed/result_type.rb#48
  sig { params(message: ::String, original_result: ::Minitest::Result).void }
  def initialize(message, original_result:); end

  # source://minitest-distributed//lib/minitest/distributed/result_type.rb#54
  sig { override.returns(::String) }
  def result_label; end

  class << self
    # source://minitest-distributed//lib/minitest/distributed/result_type.rb#59
    sig { params(result: ::Minitest::Result, attempt: ::Integer, max_attempts: ::Integer).returns(::Minitest::Result) }
    def wrap(result, attempt:, max_attempts:); end
  end
end
